###############################################################################

# CLAM System default variable definitions for C# compilation.

###############################################################################

# Pull in the base support for CLAM.
include variables.def

###############################################################################

CLAM_BIN = $(CLAM_DIR)/../bin

###############################################################################

ifneq "$(BUILD_PARAMETER_FILE)" ""
  # define our version of the build parameter file.  this should be set
  # beforehand so we override the default parameter file for clam.
  export PARAMETER_FILE = $(BUILD_PARAMETER_FILE)
###no: $(REPOSITORY_DIR)/build/identity.ini
endif
ifeq "$(PARAMETER_FILE)" ""
  # last ditch attempt to get one that will work.
  export PARAMETER_FILE = $(REPOSITORY_DIR)/build.ini
endif

###############################################################################

# BASE_CPU is a flag that distinguishes the type of processor, if necessary.
export BASE_CPU
#BASE_CPU        = m68k
  # motorola 68000 series.
#BASE_CPU        = m68340
  # motorola 68340.
#BASE_CPU        = x86
  # intel x86.
#BASE_CPU        = ppc860
  # power pc 860.

# set the CPU default if we do not have one.
ifeq "$(BASE_CPU)" ""
  BASE_CPU = x86
endif

# COMPILER is a flag that specifies the operating system or the compiler for
# use in conditional compilation (#ifdef ... #endif) of the compiler dependent
# interfaces or implementations.
export COMPILER
#COMPILER = VISUAL_CPP

# choose a default compiler if none was specified.
ifeq "$(COMPILER)" ""
  COMPILER = VISUAL_CPP
endif

# COMPILER_VERSION specifies the version of a particular compiler, if this is
# needed to distinguish how the code is built.
export COMPILER_VERSION

###############################################################################

# "TYPE" is the kind of product being generated by this project.  this is
# used to decide where to put the final products of compilation.  this is a
# variable in the user's makefile.
# Valid Types:
#     TYPE = library        (outputs are static or dynamic libraries)
#     TYPE = application    (outputs are main-line executables)
#     TYPE = test           (outputs are test programs)
export TYPE

###############################################################################

# pseudo-boolean variable section.  if these have any value at all, then they
# are treated as being true.  note that these are flags that should generally
# be passed on the command line to a make.  if they are intended to be used
# from inside a makefile, then they must appear before this file is included.

# "REBUILD" causes a rebuild of all source files if it's true.
export REBUILD

# "DEBUG" is used to specify a debugging build.  the default is for this to
# be false, which causes a release build.
export DEBUG

# "OPTIMIZE" creates optimized code.
export OPTIMIZE

# "NO_COMPILE" just runs through the targets without compiling.  it still
# promotes headers however.
export NO_COMPILE

# "BUILD_LIST_FILE" is the set of files that need to be recompiled for
# visual c++.
export BUILD_LIST_FILE = $(CLAM_TMP)/clam_rebuild.$(PROJECT)

# "BUILD_WHACK_FILE" is the set of object files that should be removed if
# a build failure occurs.
export BUILD_WHACK_FILE = $(CLAM_TMP)/clam_whack.$(PROJECT)

# we're adding the build list to the flag files so we know it gets cleaned up.
FLAG_FILES += $(BUILD_LIST_FILE) $(BUILD_WHACK_FILE)

###############################################################################

# This section implements the HOOPLE directory scheme.  If your scheme differs,
# then you'll want to modify these appropriately.

# "THIRD_PARTY_DIR" is the root of our support libraries.
ifeq "$(OP_SYSTEM)" "UNIX"
  export THIRD_PARTY_DIR
endif
ifeq "$(OP_SYSTEM)" "WIN32"
  export THIRD_PARTY_DIR = $(REPOSITORY_DIR)/3rdparty
endif

# "OUTPUT_ROOT" is the root of all output directories for objects and other
# products being built.
export OUTPUT_ROOT = $(TARGETS_DIR)/obj

# "PLATFORM_ADD_IN" is an option discriminator for the intended execution
# platform.  it should end in an underscore if it is provided.
#PLATFORM_ADD_IN = linux_
#PLATFORM_ADD_IN = w32_
PLATFORM_ADD_IN =

# "CPU_BUILD_DIR" distinguishes object directories by including the cpu
# name and the type of build.
ifneq "$(DEBUG)" ""
  CPU_BUILD_DIR = $(BASE_CPU)_dbg
else
  CPU_BUILD_DIR = $(BASE_CPU)_$(PLATFORM_ADD_IN)rel
endif

# "BASE_OUTPUT_PATH" is the parent directory of objects for this type of
# cpu and this type of build.
export BASE_OUTPUT_PATH = $(OUTPUT_ROOT)/$(CPU_BUILD_DIR)

# "OUTPUT_PATH" is the directory to generate all compiled products into.
export OUTPUT_PATH = $(BASE_OUTPUT_PATH)/$(PROJECT)

# "OBJECT_DIR" is where object files will be stored during compilation for the
# target type being produced.
export OBJECT_DIR = $(OUTPUT_PATH)

# These specify where files are to be created or located for our local build.
export EXECUTABLE_DIR = $(TARGETS_DIR)/exe
export DYNAMIC_LIBRARY_DIR = $(TARGETS_DIR)/dll
export STATIC_LIBRARY_DIR = $(TARGETS_DIR)/lib
export TESTS_DIR = $(TARGETS_DIR)/tests

# "HEADER_SEARCH_PATH" is where the class interface files are to be found.
#HEADER_SEARCH_PATH =

# "HOOPLE_HEADERS" are locations where the HOOPLE headers can be found.
HOOPLE_HEADERS := $(shell $(FIND) $(REPOSITORY_DIR)/source/lib_src $(REPOSITORY_DIR)/libraries -mindepth 1 -maxdepth 1 -type d)

# "LOCAL_HEADERS" are overrides that go first in the header search path.
#LOCAL_HEADERS =

# "CODEBASE_HEADERS" is a list that can be changed for a particular codebase.
# it is guaranteed that clam will not interfere with this list, whereas
# the LOCAL_HEADERS can be modified by clam.
#CODEBASE_HEADERS =

# "LOCAL_LIBRARIES" are overrides that go first in the library search path.
#LOCAL_LIBRARIES =

# "LIBRARY_SEARCH_PATH" is where the library files are to be found.
#LIBRARY_SEARCH_PATH =

# "HOOPLE_LIBRARIES" is where our local libraries are located.
HOOPLE_LIBRARIES =

# "EXTRA_COPIES" is a list of files that are copied to a project's output
# directory.
export EXTRA_COPIES

# "EXTRA_VERSIONS" is a list of version files to synchronize with the main
# library version for this build.  if a file called "version.ini" exists in
# the project directory, then it will automatically be upgraded, so the
# extra version files are mainly useful when you have a project with multiple
# programs in it and you want them to have independent version files (as you
# should perhaps want).
export EXTRA_VERSIONS

# "OMIT_VERSIONS" is another exclusion flag.  this one turns off the creation
# of version resource files and eliminates any references that would include
# such files.  this is needed when rebuilding version_stamper.
#OMIT_VERSIONS = t

# Add the obligatory junk to be cleaned up.  Individual compiler sections
# should customize this by adding their object output directories.
CLEANUPS += $(ACTUAL_TARGETS) $(OUTPUT_PATH) 
#hmmm: import libs for dynamic libraries on ms-win32 don't currently get
#      cleaned up nicely.

###############################################################################

# "SEARCH_DIRS" is a list of directories that should be searched for both C++
# header files and for C++ code libraries.  The items placed in SEARCH_DIRS
# are fed into both the LIBRARY_SEARCH_PATH and the HEADER_SEARCH_PATH.
#SEARCH_DIRS =

# "DEFINITIONS" is a list of compiler flags that define the value of c macros.
# These usually have the format of -D<flag>, but in this variable, only the
# <flag> itself should be listed because the compiler option -D is added
# automatically.
DEFINITIONS = CLAM_BUILT

ifneq "$(BOOT_STRAPPING)" ""
  # the software is being built from the ground up, including the binaries
  # we use for building (like value_tagger and others).
  DEFINITIONS += BOOT_STRAPPING
endif

# "UNDEFINITIONS" is a list of macros to undefine.
#UNDEFINITIONS =

#hmmm: these kinds of defines (with a value) do not work for csharp.
# GLOBAL_PRODUCT_NAME is an important variable for tagging the entire code base
# with some branding.  It is provided as a macro definition to all source
# files.  The initial value for the macro should come from the build init
# file, but if it doesn't, we pick a default.
##ifeq "$(product_name)" ""
##  DEFINITIONS += GLOBAL_PRODUCT_NAME=\\\"HOOPLE\\\"
##else
##  DEFINITIONS += GLOBAL_PRODUCT_NAME=\\\"$(product_name)\\\"
##endif

# *_PRODUCT_VERSION records parts of our version numbers for the code to see.
###DEFINITIONS += MAJOR_PRODUCT_VERSION=$(major) MINOR_PRODUCT_VERSION=$(minor)

# "DEBUG_FLAGS" these flags are used for generating specialized versions of
# object files, such as ones that include debugging code or that add code for
# profiling.
# Possible values are -g for adding GDB debugging code and -pg for adding
# gprof profiling code.
#DEBUG_FLAGS = -g
#DEBUG_FLAGS = -pg
#DEBUG_FLAGS =

# "COMPILER_FLAGS" are the flags for the pre-processor and compiler.
#COMPILER_FLAGS =

# "STRICT_WARNINGS" turns on all warnings and forces them to be considered
# as errors when encountered.
#STRICT_WARNINGS = 

# "LIBRARIAN_FLAGS" are flags that need to be passed to the library tool
# that creates static code libraries.
#LIBRARIAN_FLAGS =

# "SOURCE" is the list of files that are turned into objects.
#SOURCE =

# "LIBS_USED" are system or compiler code libraries that the targets to be
# created depend upon.
#LIBS_USED =

# "LOCAL_LIBS_USED" is very similar to the LIBS_USED, but these libraries
# actually cause executables and object files to be recompiled when the
# libraries specified have changed.  To accomplish this, these libraries MUST
# be located in the STATIC_LIBRARY_DIR rather than at some arbitrary place
# on the LIBRARY_SEARCH_PATH.
#LOCAL_LIBS_USED =

# Load flags tell the linker and loader how to deal with the files and where
# to locate library components.  The prefix goes before object files are
# listed, and the suffix after.  The prefix should have things like the
# directories to be searched for code libraries (although they should be added
# to LIBRARY_SEARCH_PATH) and the loading mode for functions (static/dynamic).
# In the suffix, actual library loading statements (like -lmath) can be
# included (although they should be listed in a different form in LIBS_USED).
# Remember that the unix loader looks for functions in libraries in a bizarre
# way: ld searches for a function only when it has already been asked for it.
# This means that it doesn't remember what functions it has already been
# provided with in the libraries and object files, and it will fail if those
# functions are only asked for after they have already been encountered.
#LOAD_FLAG_PREFIX =
#LOAD_FLAG_SUFFIX =

# The prefix used on library names, mostly for unix.
LIB_PREFIX =
# The standard suffix for static or import libraries on this operating system.
LIB_ENDING =

# Flag for specifying the library name to create.
#CREATE_LIBRARY_FLAG =

# Flag for specifying a library to include in linking.
LIBRARY_NAME_FLAG = -l

# Flag for specifying a directory to add to the search path for libs.
#LIBRARY_PATH_FLAG = -L

# Flag for specifying the name of an output from the linker.
#LINKER_OUTPUT_FLAG =

# Flag for separating linker options from compilation options for a combined
# compiler / linker.
#LINKER_OPTION_SEPARATOR =

# Flag that passes special options when building executable programs.  It is
# passed just before the LOAD_FLAG_PREFIX.
#EXE_FLAGS = 

# The name of the compiler tool.
#CC =

# The name of the library creator tool.
#LIBRARY_TOOL =

# the root name of the version file.  This is currently irrelevant on
# non-win32 platforms.
VERSION_RC_ROOT = $(shell $(SHELL) $(CLAM_DIR)/cpp/rc_name.sh)
  # we import the rc_name from our close ally, the c++ compiler definitions.

###############################################################################

# Compiler Dependent Flags
#
# "COMPILER_ROOT_DIR" is the top-level for the C++ compiler location.
# "COMPILER_HEADER_DIR" is where the compiler's headers are.
export COMPILER_HEADER_DIR
# "COMPILER_LIBRARY_DIR" is where archived libraries are.
# "CC" is the name of the C++ compiler to be used.

ifeq "$(COMPILER)" "VISUAL_CPP"
  # microsoft visual studio 7.

  LIB_ENDING = .dll
  PLATFORM_ADD_IN = w32_

  # these define special characteristics for a program being built.
  #   BASE is almost always defined and pulls in fundamental w32 support.
  #   RPC supplies the remote procedure call libraries.
  #   OLE pulls in object linking and embedding support.
  #   SECURITY links with the w32 security APIs.
  #   CLR sets options that are appropriate for managed code.
  VCPP_USE_BASE=true
  VCPP_USE_RPC=
  VCPP_USE_OLE=
  VCPP_USE_SECURITY=
  VCPP_USE_CLR=
  VCPP_VISTA_ICON=

  # the framework dir points at the .net framework to be used for compilation.
  ifeq "$(FRAMEWORK_VERSION)" ""

    # older .net 1.1.
#    SHORT_FRAMEWORK_VERSION = 1.1
#    FRAMEWORK_VERSION = $(SHORT_FRAMEWORK_VERSION).4322

    # old .net 2.0.
#    SHORT_FRAMEWORK_VERSION = 2.0
#    FRAMEWORK_VERSION = $(SHORT_FRAMEWORK_VERSION).50727

    # current .net 3.5.
    SHORT_FRAMEWORK_VERSION = 3.5
    FRAMEWORK_VERSION = $(SHORT_FRAMEWORK_VERSION)

  endif
  export FRAMEWORK_DIR 
  ifeq "$(FRAMEWORK_DIR)" ""
    FRAMEWORK_DIR = $(subst \,/,$(WINDIR))/Microsoft.NET/Framework/v$(FRAMEWORK_VERSION)
  endif

  # pick a default compiler version for what we tend to use the most at the
  # current time.
  ifeq "$(COMPILER_VERSION)" ""
    COMPILER_VERSION = 7
  endif
##  DEFINITIONS += COMPILER_VERSION=$(COMPILER_VERSION)
    # add a macro so programs can check what version is appropriate.

  # C# needs an entry point for exes.  a different one can be specified also.
  ENTRY_POINT = main

  # C# treats resources differently than simple code files.  the list in this
  # variable will be embedded in the target.
  #RESX = 

  # TLBEXPORT is a tool to create TLB files from DLL files.
  TLBEXPORT = $(COMPILER_ROOT_DIR)/../SDK/v$(SHORT_FRAMEWORK_VERSION)/bin/tlbexp$(EXE_END)

  # calculate the visual studio root directory.
  export VIS_STU_ROOT := $(shell $(SHELL) $(CLAM_DIR)/cpp/ms_root_dir.sh $(CLAM_BIN) )
  ifneq "$(VIS_STU_ROOT)" ""
    COMPILER_ROOT_DIR = $(VIS_STU_ROOT)/vc#
  endif
  ifeq "$(COMPILER_ROOT_DIR)" ""
    HOSEUP = $(shell echo The compiler directory is not set.  Please define the environment )
    HOSEUP = $(shell echo variable VSxCOMNTOOLS to point at the folder where visual C++ is installed. )
    HOSEUP =
  endif

  export COMPILER_VERSION = $(shell $(SHELL) $(CLAM_DIR)/cpp/get_version.sh $(COMPILER) $(COMPILER_ROOT_DIR) )

  # set a variable for the resource compiler for old-style resources.
  STANDARD_RC = $(VIS_STU_ROOT)/vc/bin/rc

  # set up a directory for debugging files to be stored.  these are not
  # moved with the postconditions--they are generated in place.
  export PDB_DIR=$(TARGETS_DIR)/pdb

  # set these way up here so we can override them later.
  CC                      = bash $(CLAM_DIR)/csharp/csharper.sh
##$(FRAMEWORK_DIR)/csc

#  LINK_TOOL               = $(COMPILER_ROOT_DIR)/bin/link

  # vary the locations for compiler files based on the version.
  COMPILER_HEADER_DIR = $(VIS_STU_ROOT)/vc/include $(VIS_STU_ROOT)/vc/atlmfc/include $(VIS_STU_ROOT)/vc/platformsdk/include
  COMPILER_LIBRARY_DIR = 
###$(COMPILER_ROOT_DIR)/lib $(COMPILER_ROOT_DIR)/atlmfc/lib $(COMPILER_ROOT_DIR)/platformsdk/lib
  RC = $(COMPILER_ROOT_DIR)/../SDK/v2.0/bin/resgen$(EXE_END)

  ifeq "$(COMPILER_HEADER_DIR)" ""
    HOSEUP = $(shell echo The compiler version is not set.  Please define COMPILER_VERSION.)
  endif

  DEFINITIONS            += _Windows _WINDOWS WIN32 __WIN32__ __FLAT__ VC_EXTRALEAN WIN32_LEAN_AND_MEAN ATL_NO_LEAN_AND_MEAN _WIN32_WINNT=0x403
  DEF_FILE                =
  LIBRARY_TOOL            = $(COMPILER_ROOT_DIR)/bin/lib
  LOAD_FLAG_PREFIX        = -nologo
#-subsystem:windows -machine:IX86 
  LOAD_FLAG_SUFFIX        =

  MIDL                    = midl -Oicf $(MIDL_DEFS) $(HEADER_SEARCH_PATH:%=-I% ) $(DEFINITIONS:%=-I% )
  MIDL_DEFS               = -no_robust

  # set the flags used by visual c++.
  CREATE_LIBRARY_FLAG     = -out:
  LIBRARY_NAME_FLAG       = -reference:
  LIBRARY_PATH_FLAG       = -lib:
  LINKER_OPTION_SEPARATOR = -link
  LINKER_OUTPUT_FLAG      = -out:

  # Add the extra files created by visual c++.
#is this needed now that we whack whole output path?  CLEANUPS += $(OUTPUT_PATH)/*.*db

  # put the common flags into the compiler flags.
  COMPILER_FLAGS += -nologo 
#-Fd$(PDB_DIR)/$(PROJECT)_bookkeeping.pdb -GR -GX -W3 -Zi -EHsc -GS -Gd

  ifneq "$(DEBUG)" ""
    # disable function inlining and optimizations for debug.
#    COMPILER_FLAGS += -Ob0 -Od
  else
    # enable function inlining for release only.
#    COMPILER_FLAGS += -Ob1

    ifneq "$(OPTIMIZE)" ""
      # add in fast code optimization.
#testing...
#      COMPILER_FLAGS += -O2
#trying O2 again although it seems to combust too easily.
    else
      # no optimizations.
    endif

  endif

  # check if profiling is to be enabled.
  PROFILER_FLAG =
  ifneq "$(PROFILE)" ""
    PROFILER_FLAG = -profile
  endif

  # add the common linker flags.  the debugging flag is added because we
  # want to be able to debug into release code, but since the pdb files
  # are separate, we're not exposing ourselves when we don't include them.
  LOAD_FLAG_PREFIX += $(PROFILER_FLAG) -debug
#-warn:3

  # "USE_MFC" dictates whether mfc should be allowed in the application.
  # the default is not to use MFC extension style dlls.  this can be turned
  # on in the individual makefiles that require MFC.
  #USE_MFC =

  # the library creator gets a couple of flags.
  LIBRARIAN_FLAGS += -nologo -machine:IX86

  # now, vary the flag configuration based on the flags that have been set.

  ifneq "$(CONSOLE_MODE)" ""
    # console type of applications are built using the static flag so that
    # they are more redistributable.
    DEFINITIONS += _CONSOLE
###    LOAD_FLAG_SUFFIX += -subsystem:console
    STATIC = true
  endif

  # dynamically linked library or application flags.
  ifneq "$(DEBUG)" ""
    # debug.
    DEFINITIONS += _DEBUG
#    COMPILER_FLAGS += -MDd
  else
    # release.
    DEFINITIONS += NDEBUG
#    COMPILER_FLAGS += -MD
  endif

  ifneq "$(STRICT_WARNINGS)" ""
#    COMPILER_FLAGS       += -W3 -WX
    # we have not turned on W4 because it is not really warnings for the
    # microsoft compiler.  instead, it is a bunch of blather about what the
    # compiler intends to do rather than problems in the code.
  endif

endif


