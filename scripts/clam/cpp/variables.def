###############################################################################

# CLAM System default variable definitions for C++ compilation.

###############################################################################

ifneq "$(BUILD_PARAMETER_FILE)" ""
  # define our version of the build parameter file.  this should be set
  # beforehand so we override the default parameter file for clam.
  export PARAMETER_FILE = $(BUILD_PARAMETER_FILE)
endif
ifeq "$(PARAMETER_FILE)" ""
  # last ditch attempt to get one that will work.
  export PARAMETER_FILE = $(PRODUCTION_STORE)/feisty_meow_config.ini
endif

###############################################################################

# Pull in the base support for CLAM.
include variables.def

###############################################################################

# "TYPE" is the kind of product being generated by this project.  this is
# used to decide where to put the final products of compilation.  this is a
# variable in the user makefile.
# Valid Types:
#     TYPE = library        (outputs are static or dynamic libraries)
#     TYPE = application    (outputs are main-line executables)
#     TYPE = test           (outputs are test programs)
#     TYPE = hierarchy      (there are no outputs; just invokes other makes)
export TYPE

###############################################################################

# "DEFINITIONS" is a list of compiler flags that define the value of c macros.
# These usually have the format of -D<flag>, but in this variable, only the
# <flag> itself should be listed because the compiler option -D is added
# automatically.
DEFINITIONS += CLAM_BUILT
  # simple definition that tells the code that clam is building it.

ifneq "$(BOOT_STRAPPING)" ""
  # the software is being built from the ground up, including the binaries
  # we use for building (like value_tagger and others).
  DEFINITIONS += BOOT_STRAPPING
endif

# "UNDEFINITIONS" is a list of macros to undefine.
#UNDEFINITIONS =

# GLOBAL_PRODUCT_NAME is an important variable for tagging the entire code base
# with some branding.  It is provided as a macro definition to all source
# files.  The initial value for the macro should come from the build init
# file, but if it does not, we pick a default.
ifeq "$(product_name)" ""
  GLOBAL_PRODUCT_NAME := \\\"HOOPLE\\\"
else
  GLOBAL_PRODUCT_NAME := \\\"$(product_name)\\\"
endif

# *_PRODUCT_VERSION records parts of our version numbers for the code to see.
DEFINITIONS += MAJOR_PRODUCT_VERSION=$(major) MINOR_PRODUCT_VERSION=$(minor)

# TEST_MAKEFILE tells the preconditions to check that the files specified
# in the makefile are actually present.
export TEST_MAKEFILE =

###############################################################################

# pseudo-boolean variable section.  if these have any value at all, then they
# are treated as being true.  note that these are flags that should generally
# be passed on the command line to a make.  if they are intended to be used
# from inside a makefile, then they must appear before this file is included.

# "REBUILD" causes a rebuild of all source files if it is true.
export REBUILD

# "DEBUG" is used to specify a debugging build.  the default is for this to
# be false, which causes a release build.
export DEBUG

# Add in a macro definition if debugging is turned on.  This allows us to
# easily eliminate code from release builds.
ifneq "$(DEBUG)" ""
  DEFINITIONS += __DEBUGGING__
endif

# "CONSOLE_MODE" causes the program to be generated as a console application.
# this is relevant in systems where programs are otherwise built with graphical
# user interfaces.  these are always built statically.
#CONSOLE_MODE =

# "OPTIMIZE" creates optimized code.
export OPTIMIZE

# "NO_COMPILE" just runs through the targets without compiling.
export NO_COMPILE

# "BUILD_LIST_FILE" is the set of files that need to be recompiled for
# visual c++.
export BUILD_LIST_FILE = $(CLAM_TMP)/clam_rebuild.$(PROJECT)

# "BUILD_WHACK_FILE" is the set of object files that should be removed if
# a build failure occurs.
export BUILD_WHACK_FILE = $(CLAM_TMP)/clam_whack.$(PROJECT)

# we are adding the build list to the flag files so we know it gets cleaned up.
FLAG_FILES += $(BUILD_LIST_FILE) $(BUILD_WHACK_FILE)

###############################################################################

# This section implements the HOOPLE directory scheme.  If your scheme differs,
# then you will want to modify these appropriately.

# "THIRD_PARTY_DIR" is the root of our support libraries.
export THIRD_PARTY_DIR
ifeq "$(THIRD_PARTY_DIR)" ""
  export THIRD_PARTY_DIR := "$(PRODUCTION_STORE)/3rdparty"
endif

# "OUTPUT_ROOT" is the root of all output directories for objects and other
# products being built.
export OUTPUT_ROOT = $(CLAM_TMP)/objects

# "PLATFORM_ADD_IN" is an option discriminator for the intended execution
# platform.  it should end in an underscore if it is provided.
#PLATFORM_ADD_IN = linux_ | w32_

# "CPU_BUILD_DIR" distinguishes object directories by including the CPU
# name and the type of build.
ifneq "$(DEBUG)" ""
  CPU_BUILD_DIR = $(CLAM_BASE_CPU)_$(PLATFORM_ADD_IN)dbg
else
  CPU_BUILD_DIR = $(CLAM_BASE_CPU)_$(PLATFORM_ADD_IN)rel
endif

# "BASE_OUTPUT_PATH" is the parent directory of objects for this type of
# CPU and this type of build.
export BASE_OUTPUT_PATH = $(OUTPUT_ROOT)/$(CPU_BUILD_DIR)

# special case when doing arm-linux builds
ifeq "$(CLAM_COMPILER)" "GNU_ARM_LINUX"
  export TARGETS_STORE = $(FEISTY_MEOW_APEX)/$(CPU_BUILD_DIR)
  # special output directory for firmware does not include CPU name because
  #  the repository already include the CPU name
  BASE_OUTPUT_PATH = $(OUTPUT_ROOT)
endif

# "OUTPUT_PATH" is the directory to generate all compiled products into.
export OUTPUT_PATH = $(BASE_OUTPUT_PATH)/$(PROJECT)

# "OBJECT_DIR" is where object files will be stored during compilation for the
# target type being produced.
export OBJECT_DIR = $(OUTPUT_PATH)

# These specify where files are to be created or located for our local build.
export EXECUTABLE_DIR = $(TARGETS_STORE)
export DYNAMIC_LIBRARY_DIR = $(TARGETS_STORE)
export STATIC_LIBRARY_DIR = $(TARGETS_STORE)

# "HEADER_SEARCH_PATH" is where the class interface files are to be found.
# the generated store folder is added to access the build version file.
# the binaries are added to access the system_helper.h file.
HEADER_SEARCH_PATH = $(FEISTY_MEOW_GENERATED_STORE)/versions $(FEISTY_MEOW_BINARIES)

# "LOCAL_HEADERS" are overrides that go first in the header search path.
LOCAL_HEADERS = $(THIRD_PARTY_DIR)

# "CODEBASE_HEADERS" is a list that can be changed for a particular codebase.
# it is guaranteed that clam will not interfere with this list, whereas
# the LOCAL_HEADERS can be modified by clam.
#CODEBASE_HEADERS =

# "LOCAL_LIBRARIES" are overrides that go first in the library search path.
#LOCAL_LIBRARIES =

# "LIBRARY_SEARCH_PATH" is where the library files are to be found.
#LIBRARY_SEARCH_PATH =

# "HOOPLE_LIBRARIES" is where our local libraries are located.
HOOPLE_LIBRARIES =

# "EXTRA_COPIES" is a list of files that need to be among the files copied
# to a project output folder.
export EXTRA_COPIES

# "EXTRA_VERSIONS" is a list of version files to synchronize with the main
# library version for this build.  if a file called "version.ini" exists in
# the project directory, then it will automatically be upgraded, so the
# extra version files are mainly useful when you have a project with multiple
# programs in it and you want them to have independent version files (as you
# should perhaps want).
export EXTRA_VERSIONS

# "DEPS_FILE" is where the auto-dependency information is stored.
export DEPS_FILE = $(OUTPUT_PATH)/$(PROJECT).deps

# "NO_DEPS" is an exclusion flag.  if it is defined, then no auto-dependency
# files will be generated.  this is useful if you are missing makedep or trying
# to compile it...
#NO_DEPS = t

# "OMIT_VERSIONS" is another exclusion flag.  this one turns off the creation
# of version resource files and eliminates any references that would include
# such files.  this is needed when rebuilding version_stamper.
#OMIT_VERSIONS = t

# add the cleanup values we already know.
CLEANUPS += $(OUTPUT_PATH) $(DEPS_FILE)

SUPPLEMENTAL_CLEANUP_TARGETS = cpp_add_to_cleanups_variable

# "GENDEPS" is a flag that causes dependencies to be generated into
# statically built applications.
export GENDEPS

###############################################################################

# "SEARCH_DIRS" is a list of directories that should be searched for both C++
# header files and for C++ code libraries.  The items placed in SEARCH_DIRS
# are fed into both the LIBRARY_SEARCH_PATH and the HEADER_SEARCH_PATH.
#SEARCH_DIRS =

# "DEPENDENCY_DEFINITIONS" is a list of extra definitions that only get passed
# to the makedep tool.  this can vary for each compiler.
#DEPENDENCY_DEFINITIONS =

# "DEPENDENCY_ADDITIONS" is a set of parameters passed directly to makedep.
#DEPENDENCY_ADDITIONS =

# "DEBUG_FLAGS" these flags are used for generating specialized versions of
# object files, such as ones that include debugging code or that add code for
# profiling.
# Possible values are -g for adding GDB debugging code and -pg for adding
# gprof profiling code.
#DEBUG_FLAGS = -g
#DEBUG_FLAGS = -pg
#DEBUG_FLAGS =

# "COMPILER_FLAGS" are the flags for the pre-processor and compiler.
#COMPILER_FLAGS =

# "STRICT_WARNINGS" turns on all warnings and forces them to be considered
# as errors when encountered.
#STRICT_WARNINGS = 

# "LIBRARIAN_FLAGS" are flags that need to be passed to the library tool
# that creates static code libraries.
#LIBRARIAN_FLAGS =

# "SOURCE" is the list of files that are turned into objects.
#SOURCE=

# "OBJECTS" are the files to be created by compilation and added to any
# libraries or executables that are made.
#OBJECTS =

# "EXTRA_OBJECTS" are files that are created elsewhere but need to be bound
# into the target.
#EXTRA_OBJECTS =

# "LIBS_USED" are system or compiler code libraries that the targets to be
# created depend upon.
LIBS_USED =

# "LOCAL_LIBS_USED" is very similar to the LIBS_USED, but these libraries
# actually cause executables and object files to be recompiled when the
# libraries specified have changed.  To accomplish this, these libraries MUST
# be located in the STATIC_LIBRARY_DIR rather than at some arbitrary place
# on the LIBRARY_SEARCH_PATH.
#LOCAL_LIBS_USED=

# Load flags tell the linker and loader how to deal with the files and where
# to locate library components.  The prefix goes before object files are
# listed, and the suffix after.  The prefix should have things like the
# directories to be searched for code libraries (although they should be added
# to LIBRARY_SEARCH_PATH) and the loading mode for functions (static/dynamic).
# In the suffix, actual library loading statements (like -lmath) can be
# included (although they should be listed in a different form in LIBS_USED).
# Remember that the unix loader looks for functions in libraries in a bizarre
# way: ld searches for a function only when it has already been asked for it.
# This means that it does not remember what functions it has already been
# provided with in the libraries and object files, and it will fail if those
# functions are only asked for after they have already been encountered.
#LOAD_FLAG_PREFIX =
#LOAD_FLAG_SUFFIX =

# The prefix used on library names, mostly for unix.
export LIB_PREFIX
# The standard suffix for static or import libraries on this operating system.
export LIB_ENDING

# The dynamic library ending differs between platforms.
export DYNLIB_ENDING

# Flag for specifying the library name to create.
#CREATE_LIBRARY_FLAG =

# Flag for specifying a library to include in linking.
LIBRARY_NAME_FLAG = -l

# Flag for specifying the name of an object file to include in a library or exe.
OBJECT_NAME_FLAG = -o

# Flag for specifying a directory to add to the search path for libs.
LIBRARY_PATH_FLAG = -L

# Flag for specifying the name of an output from the linker.
#LINKER_OUTPUT_FLAG =

# Flag for separating linker options from compilation options for a combined
# compiler / linker.
#LINKER_OPTION_SEPARATOR =

# Flag that passes special options when building executable programs.  It is
# passed just before the LOAD_FLAG_PREFIX.
#EXE_FLAGS = 

# The name of the compiler tool.
#CC =

# The name of the library creator tool.
#LIBRARY_TOOL =

ifeq "$(OPERATING_SYSTEM)" "WIN32"
  # the root name of the version file.  This is currently irrelevant on
  # non-windoze platforms.
  #CLAM_VERSION_RC_ROOT = $(shell $(SHELL) $(CLAM_SCRIPTS)/cpp/rc_name.sh)
  #hmmm: also currently irrelevant since we are only doing static builds.
endif

ifneq "$(CONSOLE_MODE)" ""
  # this definition can be used to signal different behavior when the app is
  # being built for console mode.  that generally implies that it should send
  # debugging info to standard out and avoid doing much with graphics.
  DEFINITIONS += CONSOLE_MODE
endif

###############################################################################

# Operating system dependent flags.
# (not so OS dependent with move to only gnu compilation...)

LIB_ENDING = .a
DYNLIB_ENDING = .so

###############################################################################

# Compiler Dependent Flags
#
# "CLAM_COMPILER_ROOT_DIR" is the top-level for the C++ compiler location.
# "COMPILER_HEADER_DIR" is where the compiler headers are.
# "COMPILER_LIBRARY_DIR" is where archived libraries are.
# "CC" is the name of the C++ compiler to be used.
export COMPILER_HEADER_DIR

# These flags may be useful across multiple compilers.
#
# "USE_SSL" brings in the OpenSSL libraries.
#USE_SSL =

# "USE_CURL" provides access to the curl library.
#USE_CURL =

# "USE_WXWIDGETS" enables wxwidget library support.
#USE_WXWIDGETS =

# "USE_XWIN" specifies that this project needs X window system support.
#USE_XWIN =

ifneq "$(OMIT_VERSIONS)" ""
  DEFINITIONS += NO_VERSION
endif

############################################################################
# compiler specific section below.
############################################################################

ifeq "$(CLAM_COMPILER)" "GNU_LINUX"
  # Unix GNU compiler...
  CC = g++
  PLATFORM_ADD_IN = linux_
  DEFINITIONS += _FILE_OFFSET_BITS=64 

  DEPENDENCY_DEFINITIONS += NO_VERSION
#hmmm: uggh, can we clean up this huge list of dep adds somehow?
  DEPENDENCY_ADDITIONS = -X/usr/include -X/usr/include/c++/$(CLAM_COMPILER_VERSION) -X/usr/include/c++/$(CLAM_COMPILER_VERSION)/tr1 -X/usr/local/include -X/usr/include/linux -X/usr/include/wx-2.8 -X/usr/lib/gcc/i586-suse-linux/$(CLAM_COMPILER_VERSION)/include -X/usr/lib/gcc/i486-linux-gnu/$(CLAM_COMPILER_VERSION)/include -X/usr/lib/gcc/i686-linux-gnu/$(CLAM_COMPILER_VERSION)/include -X/usr/lib/gcc/x86_64-linux-gnu/$(COMPILER_VERION)/include -X/usr/include/x86_64-linux-gnu -X/usr/include/i386-linux-gnu

#  ifeq "x86_64" "$(CLAM_BASE_CPU)"
#    COMPILER_LIBRARY_DIR = /lib64 /usr/lib64 /usr/local/lib64
#  else
#    COMPILER_LIBRARY_DIR = /lib /usr/lib /usr/local/lib
#  endif
  DEFINITIONS += __LINUX__ linux __linux__ UNIX unix __UNIX__ __USE_GNU 

#hmmm: move to an x win enabling area.
  # X Window System not enabled by default.
  #DEFINITIONS += __XWINDOWS__ 

  LIBRARY_TOOL = ar
  LIB_PREFIX = lib
  LOAD_FLAG_PREFIX += -Xlinker -O3 
    # -Xlinker --print-map : shows what went in and why.
    # -Xlinker -O3 : linker optimization

  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  LINKER_OUTPUT_FLAG = -o 
  LINK_TOOL = g++

  COMPILER_FLAGS += -shared-libgcc -fPIC  
  # compiler flags for gcc:
  # -finline-functions: inline functions as needed.
  # -fPIC: generate position independent code.
  # -fpic: generate position independent code, but less portable.
  # -frepo: automatic template instantiation at link time, no implicit ones.
  # -ffunction-sections: put each function in own section, improving linking.
  # -fdata-sections: put data in own section, improving linking.
  # -shared-libgcc: use the shared library version of compiler libraries.
  # -fno-exceptions: do not support exception handling and stack unwinding.

  ifeq "$(DEBUG)" ""
#    COMPILER_FLAGS += -finline-functions 
  endif
  ifneq "$(STRICT_WARNINGS)" ""
    COMPILER_FLAGS += -Wall -Werror -Wextra -Wno-long-long
  endif

  ifeq "$(CONSOLE_MODE)" ""
    LIBS_USED += dl 
     # dl=dynamic library.
  endif

  LIBS_USED += pthread rt 
     # pthread=thread libraries.
     # rt=real time libraries for shared memory.

  ifneq "$(DEBUG)" ""
    # add in debugging flags.
    COMPILER_FLAGS += -g3 -O0

##LOAD_FLAG_PREFIX += -lefence
#electric fence

###COMPILER_FLAGS += -pg
###LOAD_FLAG_PREFIX += -pg
####trying out profiling: does not work so well yet.  generates gmon.out files
####  in pretty random places.  the parameters to the linker do not even
####  mention this flag, and the compiler flags do not seem to provide an
####  option for where the file goes.  so, it is on hold.

  endif

endif

############################################################################

ifeq "$(CLAM_COMPILER)" "GNU_DARWIN"
  # Darwin kernel GNU compiler...  really more general macos (MacOS) here these days.
  CC = g++
  PLATFORM_ADD_IN = darwin
  DEFINITIONS += _FILE_OFFSET_BITS=64 

  DEPENDENCY_DEFINITIONS += NO_VERSION
#  DEPENDENCY_ADDITIONS = -X/usr/include -X/usr/include/c++/$(CLAM_COMPILER_VERSION) -X/usr/include/c++/$(CLAM_COMPILER_VERSION)/tr1 -X/usr/local/include -X/usr/include/linux -X/usr/include/wx-2.8 -X/usr/lib/gcc/i586-suse-linux/$(CLAM_COMPILER_VERSION)/include -X/usr/lib/gcc/i486-linux-gnu/$(CLAM_COMPILER_VERSION)/include
  DEPENDENCY_ADDITIONS = -X/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include

  COMPILER_HEADER_DIR := /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include
#/usr/local/include /usr/include 
#old /System/Library/Frameworks/Foundation.framework/Versions/C/Headers
#/Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include
#/Library/Developer/CommandLineTools/usr/include

#  ifeq "x86_64" "$(CLAM_BASE_CPU)"
#    COMPILER_LIBRARY_DIR = /lib64 /usr/lib64 /usr/local/lib64
#  else
#    COMPILER_LIBRARY_DIR = /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/lib
##/usr/lib /usr/local/lib
#  endif

  DEFINITIONS += UNIX unix __UNIX__ __USE_GNU 

  LIBRARY_TOOL = ar
  LIB_PREFIX = lib
  # special flags for getting rid of warnings on fd_set.
  LOAD_FLAG_PREFIX=-Wl,-U,___darwin_check_fd_set_overflow

  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  LINKER_OUTPUT_FLAG = -o 
  LINK_TOOL = g++

  # mac specific flags
  COMPILER_FLAGS += -Wno-nullability-completeness
#trying this one again, which had been turned off.
  COMPILER_FLAGS += -fgnu-runtime

  ifneq "$(DEBUG)" ""
    # add in debugging flags.
#    COMPILER_FLAGS += -g3 -O0
  endif
endif

############################################################################

ifeq "$(CLAM_COMPILER)" "GNU_ARM_LINUX"
  # ARM-linux GNU compiler...

##  CLAM_COMPILER_ROOT_DIR = /usr/local/arm-linux
#hmmm: the above is the one we may need to integrate into build_variables.sh

  CC = $(CLAM_COMPILER_ROOT_DIR)/bin/g++
  PLATFORM_ADD_IN = linux_
  SNAPGEAR_ROOT_DIR = $(HOME)/snapgear
  DEPENDENCY_DEFINITIONS += NO_VERSION

  COMPILER_HEADER_DIR = $(SNAPGEAR_ROOT_DIR)/linux-2.4.x/include
#  COMPILER_HEADER_DIR += $(SNAPGEAR_ROOT_DIR)/include 
  COMPILER_HEADER_DIR += $(CLAM_COMPILER_ROOT_DIR)/include $(CLAM_COMPILER_ROOT_DIR)/lib 
  COMPILER_HEADER_DIR += /usr/local/lib/gcc-lib/arm-linux/3.3.2/include
  
  COMPILER_LIBRARY_DIR = $(SNAPGEAR_ROOT_DIR)/lib $(CLAM_COMPILER_ROOT_DIR)/lib/be

  DEFINITIONS += linux __linux__ unix UNIX __UNIX__ __LINUX__ 

  COMPILER_FLAGS += -mbig-endian -finline-functions -ffunction-sections -fPIC -nostdinc -nostdinc++ 
  ifneq "$(STRICT_WARNINGS)" ""
    COMPILER_FLAGS += -Wall -Werror
  endif

  LIBRARY_TOOL = $(CLAM_COMPILER_ROOT_DIR)/bin/ar
  LIB_PREFIX = lib
  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  
  LINK_TOOL = $(CLAM_COMPILER_ROOT_DIR)/bin/g++
  LINKER_OUTPUT_FLAG = -o
  EXE_FLAGS = -mbig-endian
  LOAD_FLAG_PREFIX += -v -mbig-endian

  LIBS_USED += pthread dl

  ifneq "$(DEBUG)" ""
    COMPILER_FLAGS += -g3 -O0
  endif

endif

############################################################################

ifeq "$(CLAM_COMPILER)" "GNU_WINDOWS"
  # GNU compiler for MS Windoze...
  CC = g++
#  RC := $(CLAM_COMPILER_ROOT_DIR)/bin/windres
  PLATFORM_ADD_IN = w32_

  COMPILER_HEADER_DIR = $(CLAM_COMPILER_ROOT_DIR)/include $(CLAM_COMPILER_ROOT_DIR)/include/c++/3.4.2 
#$(CLAM_COMPILER_ROOT_DIR)/lib/gcc/mingw32/3.4.2/include 
###$(CLAM_COMPILER_ROOT_DIR)/usr/include/mingw $(CLAM_COMPILER_ROOT_DIR)/usr/include $(CLAM_COMPILER_ROOT_DIR)/usr/include/w32api $(CLAM_COMPILER_ROOT_DIR)/usr/include/extras

  COMPILER_LIBRARY_DIR = $(CLAM_COMPILER_ROOT_DIR)/lib
  DEFINITIONS += __GNU_WINDOWS__ _Windows _WINDOWS WIN32 __WIN32__ __FLAT__ VC_EXTRALEAN WIN32_LEAN_AND_MEAN ATL_NO_LEAN_AND_MEAN _WIN32 

  LIBRARY_TOOL = ar
  LIBRARY_PATH_FLAG = -L 
  LIB_PREFIX = lib
  LIB_ENDING = .a
  LOAD_FLAG_PREFIX += -mwindows
  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  LINKER_OUTPUT_FLAG = -o
  LINK_TOOL = g++
  MIDL = midl -Oicf $(MIDL_DEFS) $(HEADER_SEARCH_PATH:%=-I% ) $(DEFINITIONS:%=-D% )
  MIDL_DEFS = -no_robust
  # some lovely definitions used by some of the mfc and other ms code.
  DEPENDENCY_DEFINITIONS += __cplusplus __MINGW32__ _WIN32 _CHAR_UNSIGNED M_I86 _M_I86 _M_IX86=500 _WIN32_WINNT=0x501 __RPC_WIN32__ __RPCNDR_H_VERSION__ __RPCPROXY_H_VERSION__ TARGET_IS_NT40_OR_LATER PGM_SETCHILD 
#hmmm: yuck; re-evaluate need for the above dep defs.

endif

############################################################################

# these activities are done after the compiler specific stuff.

# add a definition for programs to be able to differentiate the versions.
DEFINITIONS += CLAM_COMPILER_VERSION=$(CLAM_COMPILER_VERSION)

# set a variable that scripts can use to get most of the definitions.
export VARIABLE_DEFINITION_SET := $(DEFINITIONS)

###############################################################################

