###############################################################################

# CLAM System default variable definitions for C++ compilation.

###############################################################################

ifneq "$(BUILD_PARAMETER_FILE)" ""
  # define our version of the build parameter file.  this should be set
  # beforehand so we override the default parameter file for clam.
  export PARAMETER_FILE = $(BUILD_PARAMETER_FILE)
endif
ifeq "$(PARAMETER_FILE)" ""
  # last ditch attempt to get one that will work.
  export PARAMETER_FILE = $(PRODUCTION_DIR)/feisty_meow_config.ini
endif

###############################################################################

# Pull in the base support for CLAM.
include variables.def

###############################################################################

#no # set the repository directory if it's still set to the base version.
#ifeq "$(FEISTY_MEOW_APEX)" ""
#  ifeq "$(OP_SYSTEM)" "UNIX"
#    export FEISTY_MEOW_APEX = $(HOME)/hoople
#  endif
#  ifeq "$(OP_SYSTEM)" "WIN32"
#    export FEISTY_MEOW_APEX = l:
#  endif
#endif

#export CLAM_BINARY_DIR = $(CLAM_DIR)/../bin

###############################################################################

# BASE_CPU is a flag that distinguishes the type of processor, if necessary.
export BASE_CPU
#BASE_CPU := m68k = motorola 68000 series | m68340 = motorola 68340
#    | x86 = intel x86 | ppc = power pc | arm = ARM core

# set the CPU to a default if it has not been set previously.
ifeq "$(BASE_CPU)" ""
#  ifneq "$(OP_SYSTEM)" "WIN32"
    BASE_CPU := $(shell machine 2>/dev/null || arch 2>/dev/null || uname -m 2>/dev/null || echo i686)
#  endif

#  ifeq "$(BASE_CPU)" ""
#    BASE_CPU := $(shell uname -m)
#    BASE_CPU := $(shell arch)
#    ifeq "$(BASE_CPU)" ""
#      # failed to get the cpu type.
#      BASE_CPU := x86
#    endif
#  endif
endif

# COMPILER is a flag that specifies the compiler that will be used to build
# code.  It is mainly used within CLAM itself for determining the proper
# compiler flags.
export COMPILER
#COMPILER := GNU_LINUX | GNU_ARM_LINUX | GNU_DARWIN | GNU_WINDOWS | VISUAL_CPP

# choose a default compiler if none was specified.
ifeq "$(COMPILER)" ""
  ifeq "$(OP_SYSTEM)" "UNIX"
    ifeq "$(OS_SUBCLASS)" "darwin"
      COMPILER := GNU_DARWIN
    else
      COMPILER := GNU_LINUX
    endif
  endif
  ifeq "$(OP_SYSTEM)" "WIN32"
#    COMPILER := GNU_WINDOWS
    COMPILER := VISUAL_CPP
  endif
  ifeq "$(COMPILER)" ""
    # if we get into this case, we have no idea how to set the default
    # compiler.  you may need to change the above logic for guessing it
    # anyhow.  but we will go with our favorite default.
    COMPILER := GNU_LINUX
  endif
endif

# COMPILER_VERSION specifies the version of a particular compiler, if this is
# needed to distinguish how the code is built.
export COMPILER_VERSION

###############################################################################

# "TYPE" is the kind of product being generated by this project.  this is
# used to decide where to put the final products of compilation.  this is a
# variable in the user's makefile.
# Valid Types:
#     TYPE = library        (outputs are static or dynamic libraries)
#     TYPE = application    (outputs are main-line executables)
#     TYPE = test           (outputs are test programs)
#     TYPE = hierarchy      (there are no outputs; just invokes other makes)
export TYPE

###############################################################################

# "DEFINITIONS" is a list of compiler flags that define the value of c macros.
# These usually have the format of -D<flag>, but in this variable, only the
# <flag> itself should be listed because the compiler option -D is added
# automatically.
DEFINITIONS += CLAM_BUILT
  # simple definition that tells the code that clam is building it.

ifneq "$(BOOT_STRAPPING)" ""
  # the software is being built from the ground up, including the binaries
  # we use for building (like value_tagger and others).
  DEFINITIONS += BOOT_STRAPPING
endif

# "UNDEFINITIONS" is a list of macros to undefine.
#UNDEFINITIONS =

# GLOBAL_PRODUCT_NAME is an important variable for tagging the entire code base
# with some branding.  It is provided as a macro definition to all source
# files.  The initial value for the macro should come from the build init
# file, but if it does not, we pick a default.
ifeq "$(product_name)" ""
  GLOBAL_PRODUCT_NAME := \\\"HOOPLE\\\"
else
  GLOBAL_PRODUCT_NAME := \\\"$(product_name)\\\"
endif

# *_PRODUCT_VERSION records parts of our version numbers for the code to see.
DEFINITIONS += MAJOR_PRODUCT_VERSION=$(major) MINOR_PRODUCT_VERSION=$(minor)

# TEST_MAKEFILE tells the preconditions to check that the files specified
# in the makefile are actually present.
export TEST_MAKEFILE =

###############################################################################

# pseudo-boolean variable section.  if these have any value at all, then they
# are treated as being true.  note that these are flags that should generally
# be passed on the command line to a make.  if they are intended to be used
# from inside a makefile, then they must appear before this file is included.

# "REBUILD" causes a rebuild of all source files if it's true.
export REBUILD

# "DEBUG" is used to specify a debugging build.  the default is for this to
# be false, which causes a release build.
export DEBUG

# Add in a macro definition if debugging is turned on.  This allows us to
# easily eliminate code from release builds.
ifneq "$(DEBUG)" ""
  DEFINITIONS += __DEBUGGING__
endif

# "CONSOLE_MODE" causes the program to be generated as a console application.
# this is relevant in systems where programs are otherwise built with graphical
# user interfaces.  these are always built statically.
#CONSOLE_MODE =

# "OPTIMIZE" creates optimized code.
export OPTIMIZE

# "NO_COMPILE" just runs through the targets without compiling.
export NO_COMPILE

# "BUILD_LIST_FILE" is the set of files that need to be recompiled for
# visual c++.
export BUILD_LIST_FILE = $(CLAM_TMP)/clam_rebuild.$(PROJECT)

# "BUILD_WHACK_FILE" is the set of object files that should be removed if
# a build failure occurs.
export BUILD_WHACK_FILE = $(CLAM_TMP)/clam_whack.$(PROJECT)

# we are adding the build list to the flag files so we know it gets cleaned up.
FLAG_FILES += $(BUILD_LIST_FILE) $(BUILD_WHACK_FILE)

###############################################################################

# This section implements the HOOPLE directory scheme.  If your scheme differs,
# then you'll want to modify these appropriately.

# "THIRD_PARTY_DIR" is the root of our support libraries.
export THIRD_PARTY_DIR
ifeq "$(THIRD_PARTY_DIR)" ""
  export THIRD_PARTY_DIR := "$(PRODUCTION_DIR)/3rdparty"
endif

# "OUTPUT_ROOT" is the root of all output directories for objects and other
# products being built.
export OUTPUT_ROOT = $(CLAM_TMP)/objects

# "PLATFORM_ADD_IN" is an option discriminator for the intended execution
# platform.  it should end in an underscore if it is provided.
#PLATFORM_ADD_IN = linux_ | w32_

# "CPU_BUILD_DIR" distinguishes object directories by including the CPU
# name and the type of build.
ifneq "$(DEBUG)" ""
  CPU_BUILD_DIR = $(BASE_CPU)_$(PLATFORM_ADD_IN)dbg
else
  CPU_BUILD_DIR = $(BASE_CPU)_$(PLATFORM_ADD_IN)rel
endif

# "BASE_OUTPUT_PATH" is the parent directory of objects for this type of
# CPU and this type of build.
export BASE_OUTPUT_PATH = $(OUTPUT_ROOT)/$(CPU_BUILD_DIR)

# special case when doing arm-linux builds
ifeq "$(COMPILER)" "GNU_ARM_LINUX"
  export TARGETS_DIR = $(FEISTY_MEOW_APEX)/$(CPU_BUILD_DIR)
  # special output directory for firmware doesn't include CPU name because
  #  the repository already include the CPU name
  BASE_OUTPUT_PATH = $(OUTPUT_ROOT)
endif

# "OUTPUT_PATH" is the directory to generate all compiled products into.
export OUTPUT_PATH = $(BASE_OUTPUT_PATH)/$(PROJECT)

# "OBJECT_DIR" is where object files will be stored during compilation for the
# target type being produced.
export OBJECT_DIR = $(OUTPUT_PATH)

# These specify where files are to be created or located for our local build.
export EXECUTABLE_DIR = $(TARGETS_DIR)
export DYNAMIC_LIBRARY_DIR = $(TARGETS_DIR)
export STATIC_LIBRARY_DIR = $(TARGETS_DIR)

# "HEADER_SEARCH_PATH" is where the class interface files are to be found.
#HEADER_SEARCH_PATH =

# "HOOPLE_HEADERS" are locations where the HOOPLE headers can be found.
ifeq "$(HOOPLE_HEADERS)" ""
#seems like some of this is redundant with earlier 3rdparty exploring.
  LOCUS_LIBRARY_HEADERS = $(shell bash -c '\
    if [ -d "$(FEISTY_MEOW_APEX)/nucleus" ]; then \
      echo "$(FEISTY_MEOW_APEX)/nucleus" "$(FEISTY_MEOW_APEX)/octopi" "$(FEISTY_MEOW_APEX)/graphiq" ; \
    else \
      echo ""; \
    fi | tr "\\\\" / | sed -e "s/\([a-zA-Z]\):\/\([^ ]*\)/\/cygdrive\/\1\/\2/g" ')
    # above assumes cygwin support for windows!  was assuming msys support.
  HOOPLE_HEADERS := $(shell $(FIND) $(LOCUS_LIBRARY_HEADERS) -mindepth 1 -maxdepth 1 -type d )
endif

# "LOCAL_HEADERS" are overrides that go first in the header search path.
LOCAL_HEADERS = $(THIRD_PARTY_DIR)

# "CODEBASE_HEADERS" is a list that can be changed for a particular codebase.
# it is guaranteed that clam will not interfere with this list, whereas
# the LOCAL_HEADERS can be modified by clam.
#CODEBASE_HEADERS =

# "LOCAL_LIBRARIES" are overrides that go first in the library search path.
#LOCAL_LIBRARIES =

# "LIBRARY_SEARCH_PATH" is where the library files are to be found.
#LIBRARY_SEARCH_PATH =

# "HOOPLE_LIBRARIES" is where our local libraries are located.
HOOPLE_LIBRARIES =

# "EXTRA_COPIES" is a list of files that need to be among the files copied
# to a project's output folder.
export EXTRA_COPIES

# "EXTRA_VERSIONS" is a list of version files to synchronize with the main
# library version for this build.  if a file called "version.ini" exists in
# the project directory, then it will automatically be upgraded, so the
# extra version files are mainly useful when you have a project with multiple
# programs in it and you want them to have independent version files (as you
# should perhaps want).
export EXTRA_VERSIONS

# "DEPS_FILE" is where the auto-dependency information is stored.
export DEPS_FILE = $(OUTPUT_PATH)/$(PROJECT).deps

# "NO_DEPS" is an exclusion flag.  if it is defined, then no auto-dependency
# files will be generated.  this is useful if you're missing makedep or trying
# to compile it...
#NO_DEPS = t

# "OMIT_VERSIONS" is another exclusion flag.  this one turns off the creation
# of version resource files and eliminates any references that would include
# such files.  this is needed when rebuilding version_stamper.
#OMIT_VERSIONS = t

# Add the obligatory junk to be cleaned up.  Individual compiler sections
# should customize this by adding their object output directories.
CLEANUPS += $(ACTUAL_TARGETS) $(OUTPUT_PATH)

# "GENDEPS" is a flag that causes dependencies to be generated into
# statically built applications.
export GENDEPS

###############################################################################

# "SEARCH_DIRS" is a list of directories that should be searched for both C++
# header files and for C++ code libraries.  The items placed in SEARCH_DIRS
# are fed into both the LIBRARY_SEARCH_PATH and the HEADER_SEARCH_PATH.
#SEARCH_DIRS =

# "DEPENDENCY_DEFINITIONS" is a list of extra definitions that only get passed
# to the makedep tool.  this can vary for each compiler.
#DEPENDENCY_DEFINITIONS =

# "DEPENDENCY_ADDITIONS" is a set of parameters passed directly to makedep.
#DEPENDENCY_ADDITIONS =

# "DEBUG_FLAGS" these flags are used for generating specialized versions of
# object files, such as ones that include debugging code or that add code for
# profiling.
# Possible values are -g for adding GDB debugging code and -pg for adding
# gprof profiling code.
#DEBUG_FLAGS = -g
#DEBUG_FLAGS = -pg
#DEBUG_FLAGS =

# "COMPILER_FLAGS" are the flags for the pre-processor and compiler.
#COMPILER_FLAGS =

# "STRICT_WARNINGS" turns on all warnings and forces them to be considered
# as errors when encountered.
#STRICT_WARNINGS = 

# "LIBRARIAN_FLAGS" are flags that need to be passed to the library tool
# that creates static code libraries.
#LIBRARIAN_FLAGS =

# "SOURCE" is the list of files that are turned into objects.
#SOURCE=

# "OBJECTS" are the files to be created by compilation and added to any
# libraries or executables that are made.
#OBJECTS =

# "EXTRA_OBJECTS" are files that are created elsewhere but need to be bound
# into the target.
#EXTRA_OBJECTS =

# "LIBS_USED" are system or compiler code libraries that the targets to be
# created depend upon.
LIBS_USED =

# "LOCAL_LIBS_USED" is very similar to the LIBS_USED, but these libraries
# actually cause executables and object files to be recompiled when the
# libraries specified have changed.  To accomplish this, these libraries MUST
# be located in the STATIC_LIBRARY_DIR rather than at some arbitrary place
# on the LIBRARY_SEARCH_PATH.
#LOCAL_LIBS_USED=

# Load flags tell the linker and loader how to deal with the files and where
# to locate library components.  The prefix goes before object files are
# listed, and the suffix after.  The prefix should have things like the
# directories to be searched for code libraries (although they should be added
# to LIBRARY_SEARCH_PATH) and the loading mode for functions (static/dynamic).
# In the suffix, actual library loading statements (like -lmath) can be
# included (although they should be listed in a different form in LIBS_USED).
# Remember that the unix loader looks for functions in libraries in a bizarre
# way: ld searches for a function only when it has already been asked for it.
# This means that it doesn't remember what functions it has already been
# provided with in the libraries and object files, and it will fail if those
# functions are only asked for after they have already been encountered.
#LOAD_FLAG_PREFIX =
#LOAD_FLAG_SUFFIX =

# The prefix used on library names, mostly for unix.
export LIB_PREFIX
# The standard suffix for static or import libraries on this operating system.
export LIB_ENDING

# The dynamic library ending differs between platforms.
export DYNLIB_ENDING

# Flag for specifying the library name to create.
#CREATE_LIBRARY_FLAG =

# Flag for specifying a library to include in linking.
LIBRARY_NAME_FLAG = -l

# Flag for specifying the name of an object file to include in a library or exe.
OBJECT_NAME_FLAG = -o

# Flag for specifying a directory to add to the search path for libs.
LIBRARY_PATH_FLAG = -L

# Flag for specifying the name of an output from the linker.
#LINKER_OUTPUT_FLAG =

# Flag for separating linker options from compilation options for a combined
# compiler / linker.
#LINKER_OPTION_SEPARATOR =

# Flag that passes special options when building executable programs.  It is
# passed just before the LOAD_FLAG_PREFIX.
#EXE_FLAGS = 

# The name of the compiler tool.
#CC =

# The name of the library creator tool.
#LIBRARY_TOOL =

# the root name of the version file.  This is currently irrelevant on
# non-win32 platforms.
VERSION_RC_ROOT = $(shell $(SHELL) $(CLAM_DIR)/cpp/rc_name.sh)

ifneq "$(CONSOLE_MODE)" ""
  # this definition can be used to signal different behavior when the app is
  # being built for console mode.  that generally implies that it should send
  # debugging info to standard out and avoid doing much with graphics.
  DEFINITIONS += CONSOLE_MODE
endif

###############################################################################

# Operating system dependent flags.

ifeq "$(OP_SYSTEM)" "UNIX"
  LIB_ENDING = .a
  DYNLIB_ENDING = .so
endif
ifeq "$(OP_SYSTEM)" "WIN32"
  ifeq "$(COMPILER)" "VISUAL_CPP"
    LIB_ENDING = .lib
    DYNLIB_ENDING = .dll
  else
    LIB_ENDING = .a
    DYNLIB_ENDING = .so
  endif
endif

###############################################################################

# Compiler Dependent Flags
#
# "COMPILER_ROOT_DIR" is the top-level for the C++ compiler location.
export COMPILER_ROOT_DIR
# "COMPILER_HEADER_DIR" is where the compiler's headers are.
export COMPILER_HEADER_DIR
# "COMPILER_LIBRARY_DIR" is where archived libraries are.
# "CC" is the name of the C++ compiler to be used.

# These flags may be useful across multiple compilers.
#
# SSL brings in the OpenSSL libraries.
USE_SSL=

# CURL provides access to the curl library.
USE_CURL=

# Enables wxwidget library support.
USE_WXWIDGETS=

ifneq "$(OMIT_VERSIONS)" ""
  DEFINITIONS += NO_VERSION
endif

ifeq "$(COMPILER)" "GNU_LINUX"
  # Unix GNU compiler...
  CC = g++
  COMPILER_ROOT_DIR = /
  PLATFORM_ADD_IN = linux_
  ARCHITECTURE = $(shell machine 2>/dev/null || arch 2>/dev/null || echo i686)

  export COMPILER_VERSION = $(shell $(SHELL) $(CLAM_DIR)/cpp/get_version.sh $(COMPILER) $(COMPILER_ROOT_DIR) )

  DEFINITIONS += _FILE_OFFSET_BITS=64 

  DEPENDENCY_DEFINITIONS += NO_VERSION
  DEPENDENCY_ADDITIONS = -X/usr/include -X/usr/include/c++/$(COMPILER_VERSION) -X/usr/include/c++/$(COMPILER_VERSION)/tr1 -X/usr/local/include -X/usr/include/linux -X/usr/include/wx-2.8 -X/usr/lib/gcc/i586-suse-linux/$(COMPILER_VERSION)/include -X/usr/lib/gcc/i486-linux-gnu/$(COMPILER_VERSION)/include -X/usr/lib/gcc/i686-linux-gnu/$(COMPILER_VERSION)/include -X/usr/lib/gcc/x86_64-linux-gnu/$(COMPILER_VERION)/include -X/usr/include/x86_64-linux-gnu -X/usr/include/i386-linux-gnu

  # "USE_XWIN" specifies that this project needs X window system support.
  #USE_XWIN =

  ifeq "x86_64" "$(ARCHITECTURE)"
    COMPILER_LIBRARY_DIR = /lib64 /usr/lib64 /usr/local/lib64
  else
    COMPILER_LIBRARY_DIR = /lib /usr/lib /usr/local/lib
  endif
  DEFINITIONS += __LINUX__ linux __linux__ UNIX unix __UNIX__ __USE_GNU 
  # X Window System not enabled by default.
  #DEFINITIONS += __XWINDOWS__ 

  LIBRARY_TOOL = ar
  LIB_PREFIX = lib
  LOAD_FLAG_PREFIX += -Xlinker -O3 
    # -Xlinker --print-map : shows what went in and why.
    # -Xlinker -O3 : linker optimization

  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  LINKER_OUTPUT_FLAG = -o 
  LINK_TOOL = g++
  # compiler flags for gcc:
  # -finline-functions: inline functions as needed.
  # -fPIC: generate position independent code.
  # -fpic: generate position independent code, but less portable.
  # -frepo: automatic template instantiation at link time, no implicit ones.
  # -ffunction-sections: put each function in own section, improving linking.
  # -fdata-sections: put data in own section, improving linking.
  # -shared-libgcc: use the shared library version of compiler libraries.
  # -fno-exceptions: do not support exception handling and stack unwinding.

  COMPILER_FLAGS += -shared-libgcc -fPIC  

  ifeq "$(DEBUG)" ""
#    COMPILER_FLAGS += -finline-functions 
  endif
  ifneq "$(STRICT_WARNINGS)" ""
    COMPILER_FLAGS += -Wall -Werror -Wextra -Wno-long-long
  endif

  ifeq "$(CONSOLE_MODE)" ""
    LIBS_USED += dl 
     # dl=dynamic library.
  endif

  LIBS_USED += pthread rt 
     # pthread=thread libraries.
     # rt=real time libraries for shared memory.

  ifneq "$(DEBUG)" ""
    # add in debugging flags.
    COMPILER_FLAGS += -g3 -O0

##LOAD_FLAG_PREFIX += -lefence
#electric fence

###COMPILER_FLAGS += -pg
###LOAD_FLAG_PREFIX += -pg
####trying out profiling: doesn't work so well yet.  generates gmon.out files
####  in pretty random places.  the parameters to the linker don't even
####  mention this flag, and the compiler flags don't seem to provide an
####  option for where the file goes.  so, it's on hold.

  endif

endif

ifeq "$(COMPILER)" "GNU_ARM_LINUX"
  # ARM-linux GNU compiler...
  COMPILER_ROOT_DIR = /usr/local/arm-linux
  CC = $(COMPILER_ROOT_DIR)/bin/g++
  PLATFORM_ADD_IN = linux_

  export COMPILER_VERSION = $(shell $(SHELL) $(CLAM_DIR)/cpp/get_version.sh $(COMPILER) $(COMPILER_ROOT_DIR) )

  SNAPGEAR_ROOT_DIR = $(HOME)/snapgear

  DEPENDENCY_DEFINITIONS += NO_VERSION

  COMPILER_HEADER_DIR = $(SNAPGEAR_ROOT_DIR)/linux-2.4.x/include
#  COMPILER_HEADER_DIR += $(SNAPGEAR_ROOT_DIR)/include 
  COMPILER_HEADER_DIR += $(COMPILER_ROOT_DIR)/include $(COMPILER_ROOT_DIR)/lib 
  COMPILER_HEADER_DIR += /usr/local/lib/gcc-lib/arm-linux/3.3.2/include
  
  COMPILER_LIBRARY_DIR = $(SNAPGEAR_ROOT_DIR)/lib $(COMPILER_ROOT_DIR)/lib/be

  DEFINITIONS += linux __linux__ unix UNIX __UNIX__ __LINUX__ 

  COMPILER_FLAGS += -mbig-endian -finline-functions -ffunction-sections -fPIC -nostdinc -nostdinc++ 
  ifneq "$(STRICT_WARNINGS)" ""
    COMPILER_FLAGS += -Wall -Werror
  endif

  LIBRARY_TOOL = $(COMPILER_ROOT_DIR)/bin/ar
  LIB_PREFIX = lib
  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  
  LINK_TOOL = $(COMPILER_ROOT_DIR)/bin/g++
  LINKER_OUTPUT_FLAG = -o
  EXE_FLAGS = -mbig-endian
  LOAD_FLAG_PREFIX += -v -mbig-endian

  LIBS_USED += pthread dl

  ifneq "$(DEBUG)" ""
    COMPILER_FLAGS += -g3 -O0
  endif

endif

ifeq "$(COMPILER)" "GNU_WINDOWS"
  # GNU compiler for MS Windoze...
  CC = g++
  ifeq "$(COMPILER_ROOT_DIR)" ""
    COMPILER_ROOT_DIR = $(CYGROOT)
  endif

  export COMPILER_VERSION = $(shell $(SHELL) $(CLAM_DIR)/cpp/get_version.sh $(COMPILER) $(COMPILER_ROOT_DIR) )

  RC := $(COMPILER_ROOT_DIR)/bin/windres
  PLATFORM_ADD_IN = w32_

  COMPILER_HEADER_DIR = $(COMPILER_ROOT_DIR)/include $(COMPILER_ROOT_DIR)/include/c++/3.4.2 
#$(COMPILER_ROOT_DIR)/lib/gcc/mingw32/3.4.2/include 
###$(COMPILER_ROOT_DIR)/usr/include/mingw $(COMPILER_ROOT_DIR)/usr/include $(COMPILER_ROOT_DIR)/usr/include/w32api $(COMPILER_ROOT_DIR)/usr/include/extras

  COMPILER_LIBRARY_DIR = $(COMPILER_ROOT_DIR)/lib
  DEFINITIONS += __GNU_WINDOWS__ _Windows _WINDOWS WIN32 __WIN32__ __FLAT__ VC_EXTRALEAN WIN32_LEAN_AND_MEAN ATL_NO_LEAN_AND_MEAN _WIN32 __USE_W32_SOCKETS
#__cplusplus 
#__USE_GNU 

  LIBRARY_TOOL = ar
  LIBRARY_PATH_FLAG = -L 
  LIB_PREFIX = lib
#  LOAD_FLAG_PREFIX += -lpthread
  LOAD_FLAG_PREFIX += -mwindows
  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  LINKER_OUTPUT_FLAG = -o
  LINK_TOOL = g++
  MIDL = midl -Oicf $(MIDL_DEFS) $(HEADER_SEARCH_PATH:%=-I% ) $(DEFINITIONS:%=-D% )
  MIDL_DEFS = -no_robust
  # some lovely definitions used by some of the mfc and other ms code.
  DEPENDENCY_DEFINITIONS += __cplusplus __MINGW32__ _WIN32 _CHAR_UNSIGNED M_I86 _M_I86 _M_IX86=500 _WIN32_WINNT=0x501 __RPC_WIN32__ __RPCNDR_H_VERSION__ __RPCPROXY_H_VERSION__ TARGET_IS_NT40_OR_LATER PGM_SETCHILD _MFC_VER=0x0600

endif

ifeq "$(COMPILER)" "VISUAL_CPP"
  # microsoft visual c++ 4.x, 5.x or 6.x.

  PLATFORM_ADD_IN = w32_

  TRIPART_VERSION =

  CLEANUPS += $(PDB_DIR)/$(PROJECT)_bookkeeping.pdb 
#hmmm: import libs for dynamic libraries on ms-win32 don't currently get
#      cleaned up nicely.

  # ensure that any setting for this is seen by sub-shells.
  export WIN32_MANIFEST_FILE

  # these define special characteristics for a program being built.
  #   BASE is almost always defined and pulls in fundamental w32 support.
  #   RPC supplies the remote procedure call libraries.
  #   SECURITY links with the w32 security APIs.
  #   CLR sets options that are appropriate for managed code.
  VCPP_USE_BASE=true
  VCPP_USE_RPC=
  VCPP_USE_OLE=
  VCPP_USE_SECURITY=
  VCPP_USE_CLR=
  VCPP_VISTA_ICON=

  # the framework dir points at the .net framework to be used for compilation.
  ifeq "$(FRAMEWORK_VERSION)" ""

    # older .net 1.1.
#    SHORT_FRAMEWORK_VERSION = 1.1
#    FRAMEWORK_VERSION = $(SHORT_FRAMEWORK_VERSION).4322

    # current .net 2.0.
    SHORT_FRAMEWORK_VERSION = 2.0
    FRAMEWORK_VERSION = $(SHORT_FRAMEWORK_VERSION).50727
  endif
  ifeq "$(FRAMEWORK_DIR)" ""
    FRAMEWORK_DIR = $(subst \,/,$(WINDIR))/Microsoft.NET/Framework/v$(FRAMEWORK_VERSION)
  endif

  # calculate the visual studio root directory.
  ifeq "$(VIS_STU_ROOT)" ""
    export VIS_STU_ROOT := $(shell $(SHELL) $(CLAM_DIR)/cpp/ms_root_dir.sh )
  endif
  ifneq "$(VIS_STU_ROOT)" ""
    export COMPILER_ROOT_DIR = $(VIS_STU_ROOT)/VC
  endif
  ifeq "$(COMPILER_ROOT_DIR)" ""
    HOSEUP = $(shell echo The compiler directory is not set.  Please define the environment variable)
    HOSEUP = $(shell echo VSxCOMNTOOLS (x=80, 90 or 100) to point at the folder where visual )
    HOSEUP = $(shell echo Studio is installed.)
    HOSEUP =
  endif

  # redo the compiler version with our new info.
  export COMPILER_VERSION := $(shell $(SHELL) $(CLAM_DIR)/cpp/get_version.sh $(COMPILER) $(COMPILER_ROOT_DIR) )

  # set up a directory for debugging files to be stored.  these are not
  # moved with the postconditions--they are generated in place.
  export PDB_DIR = $(TARGETS_DIR)

  # set these way up here so we can override them later.
  CC = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(COMPILER_ROOT_DIR)/bin/cl.exe
  LINK_TOOL = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(COMPILER_ROOT_DIR)/bin/link.exe
  LIBRARY_TOOL = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(COMPILER_ROOT_DIR)/bin/lib

  # This is needed to protect against the use of 64-bit time_t structure
  # on windows.  We are casting to time_t from a 32-bit structure.
  DEFINITIONS += _USE_32BIT_TIME_T

  # vary the locations for compiler files based on the version.
  ifeq "$(COMPILER_VERSION)" "6"
    COMPILER_HEADER_DIR = $(COMPILER_ROOT_DIR)/include $(COMPILER_ROOT_DIR)/atl/include
    COMPILER_LIBRARY_DIR = $(COMPILER_ROOT_DIR)/lib $(COMPILER_ROOT_DIR)/atl/lib
    RC = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(COMPILER_ROOT_DIR)/../common/msdev98/bin/rc
  endif
  ifeq "$(COMPILER_VERSION)" "7"
    COMPILER_HEADER_DIR = $(COMPILER_ROOT_DIR)/include $(COMPILER_ROOT_DIR)/atlmfc/include $(COMPILER_ROOT_DIR)/platformsdk/include $(FRAMEWORK_DIR)
    COMPILER_LIBRARY_DIR = $(COMPILER_ROOT_DIR)/lib $(COMPILER_ROOT_DIR)/atlmfc/lib $(COMPILER_ROOT_DIR)/platformsdk/lib
    RC = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(COMPILER_ROOT_DIR)/bin/rc
    COMPILER_FLAGS += -Zc:forScope
      # turn on proper loop scoping.
  endif
  ifeq "$(COMPILER_VERSION)" "8"
    COMPILER_HEADER_DIR = $(COMPILER_ROOT_DIR)/include $(COMPILER_ROOT_DIR)/atlmfc/include $(COMPILER_ROOT_DIR)/platformsdk/include $(FRAMEWORK_DIR)
    COMPILER_LIBRARY_DIR = $(COMPILER_ROOT_DIR)/lib $(COMPILER_ROOT_DIR)/atlmfc/lib $(COMPILER_ROOT_DIR)/platformsdk/lib
    RC = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(COMPILER_ROOT_DIR)/bin/rc
    COMPILER_FLAGS += -Zc:forScope
      # turn on proper loop scoping.
    DEFINITIONS += _WIN32_WINNT=0x501 
    DEPENDENCY_DEFINITIONS += _WIN32_WINNT=0x501 
  endif
#
# ver 9 (vis stu 2008) is not in here but is probably similar to 8 or 10.
#
  ifeq "$(COMPILER_VERSION)" "10"
    export PLATYPUS = $(WindowsSdkDir)
    COMPILER_HEADER_DIR = $(COMPILER_ROOT_DIR)/include $(COMPILER_ROOT_DIR)/atlmfc/include $(PLATYPUS)/include
## $(FRAMEWORK_DIR)
    COMPILER_LIBRARY_DIR = $(COMPILER_ROOT_DIR)/lib $(COMPILER_ROOT_DIR)/atlmfc/lib $(PLATYPUS)/lib
    DEFINITIONS += _WIN32_WINNT=0x501 
    DEPENDENCY_DEFINITIONS += _WIN32_WINNT=0x501 
    RC = $(BUILD_SCRIPTS_DIR)/wrapdoze.sh $(PLATYPUS)/bin/rc
    COMPILER_FLAGS += -Zc:forScope
      # turn on proper loop scoping.
  endif
  ifeq "$(COMPILER_HEADER_DIR)" ""
    HOSEUP = $(shell echo The compiler version is not set.  Please define COMPILER_VERSION.)
  endif
  ifeq "$(COMPILER_HEADER_DIR)" ""
    HOSEUP = $(shell echo The compiler version is not set.  Please define COMPILER_VERSION.)
  endif
  ifeq "$(COMPILER_HEADER_DIR)" "0"
    HOSEUP = $(shell echo The compiler version is not set.  Please define COMPILER_VERSION.)
  endif

  # add in the mfc directories.
  COMPILER_HEADER_DIR += $(COMPILER_ROOT_DIR)/mfc/include
  COMPILER_LIBRARY_DIR += $(COMPILER_ROOT_DIR)/mfc/lib

  DEFINITIONS += _Windows _WINDOWS WIN32 __WIN32__ __FLAT__ VC_EXTRALEAN WIN32_LEAN_AND_MEAN ATL_NO_LEAN_AND_MEAN 
  DEF_FILE =
  LOAD_FLAG_PREFIX = -subsystem:windows -machine:X86 -nologo
  LOAD_FLAG_SUFFIX =

  MIDL = "$(COMPILER_ROOT_DIR)/../Common7/Tools/Bin"/midl.exe -Oicf $(MIDL_DEFS) $(HEADER_SEARCH_PATH:%=-I% ) $(DEFINITIONS:%=-D% )
  MIDL_DEFS = -no_robust

  # additional definitions that get put on the command line for makedep.  these
  # are needed since visual c++ defines them automatically.
  DEPENDENCY_DEFINITIONS += __cplusplus _WIN32 _CHAR_UNSIGNED M_I86 _M_I86 _MSC_VER=1200 _M_IX86=500 __RPC_WIN32__ __RPCNDR_H_VERSION__ __RPCPROXY_H_VERSION__ TARGET_IS_NT40_OR_LATER PGM_SETCHILD _MFC_VER=0x0600

  # set the flags used by visual c++.
  CREATE_LIBRARY_FLAG = -out:
  LIBRARY_NAME_FLAG =
  LIBRARY_PATH_FLAG = -libpath:
  LINKER_OPTION_SEPARATOR = -link
  LINKER_OUTPUT_FLAG = -out:
  OBJECT_NAME_FLAG = -Fo

  # Add the extra files created by visual c++.
#is this needed now that we whack whole output path?  CLEANUPS += $(OUTPUT_PATH)/*.*db

  # compilation parameters for microsoft.
  #   -c specifies compilation without linking.
  #   -EHsc is the flag for turning on exception handling.
  #   -FD is for getting the best dependency checking in visual studio.
  #   -Fd[filename] names the program database (PDB) file used for debugging.
  #   -Fp[filename] names the precompiled header file name.
  #   -FR[filename] names the browser output path used for source analysis.
  #   -Gd calling convention is cdecl.
  #   -Gm enables minimal rebuild (only if source files changed).
  #       Note!  as of Visual Studio 6 SP 3, minimal rebuild does not work
  #       properly.  Do not use it unless you want inconsistent builds!
  #   -GR enables run-time type identification (RTTI).
  #   -GS enables buffer checking.
  #   -GX turns on synchronous exception handling. (deprecated)
  #   -Gz uses __stdcall calling convention.
  #   -MD specifies multi-threaded DLL (MDd means debug).
  #   -ML signifies uni-threaded executable (MLd means debug).
  #   -MT indicates multi-threaded executable (MTd means debug)
  #   -O is for optimization (1 small code, 2 fast code, d disabled).
  #     don't use 1 or 2 though; they both include "global optimization",
  #     which seems plagued with problems.  the specific optimizations are:
  #       -Oa  assume no aliasing
  #       -Obn  inline function expansion, where n is 1 (enable) or 0 (disable)
  #       -Od  disable (for debug)
  #       -Oi  generate intrinsic functions
  #       -Og  global optimizations (flawed)
  #       -Op  improve float consistency
  #       -Os  favor small code
  #       -Ot  favor fast code
  #       -Ow  assume aliasing across function calls
  #       -Ox  full optimization
  #       -Oy  frame pointer optimization
  #     -O1 has g s y b1 Gs Gf Gy
  #     -O2 has g i t y b1 Gs Gf Gy
  #   -TP C++ compilation.
  #   -W sets the warning level (from 0 (least warnings) through 4 (loudest)).
  #       -WX turns all warnings into errors.
  #   -Yu[filename] uses a precompiled header file.
  #   -YX turns on precompiled headers.  not used due to poor implementation.
  #   -Zi generates debugging information into the PDB file.

  # put the common flags into the compiler flags.
  COMPILER_FLAGS += -nologo -Fd$(PDB_DIR)/$(PROJECT)_bookkeeping.pdb -GR -W3 -Zi -EHsc -GS -Gd 
#-Wp64 

  ifneq "$(DEBUG)" ""
    # disable function inlining and optimizations for debug.
    COMPILER_FLAGS += -Ob0 -Od
  else
    # enable function inlining for release only.
    COMPILER_FLAGS += -Ob1

    ifneq "$(OPTIMIZE)" ""
      # add in fast code optimization.
      COMPILER_FLAGS += -O2
    else
      # no optimizations.
    endif

  endif

  # linking parameters for microsoft.
  #   -dll specifies that a dynamic library is to be created.
  #   -debug specifies that debugging information is to be included.
  #   -map turns on the map file.
  #   -warn sets the warning level, from 0 to 3, where 3 is the most verbose.
  #   kernel32.lib is the kernel support.
  #   user32.lib is the user level support.
  #   gdi32.lib is the graphical device interface? support.
  #   winspool.lib contains printer support.
  #   comdlg32.lib provides the common dialogs.
  #   advapi32.lib provides deeper win32 features, like registry, services, etc.
  #   shell32.lib is ?
  #   ole32.lib supplies OLE support.
  #   oleaut32.lib is the OLE automation library.
  #   uuid.lib has unique id management?
  #   odbc32.lib provides ODBC data source functionality.
  #   odbccp32.lib is something?
  #   winmm.lib has the win32 multimedia support.
  #   version.lib offers up splendid version services.

  # check if profiling is to be enabled.
  PROFILER_FLAG =
  ifneq "$(PROFILE)" ""
    PROFILER_FLAG = -profile
  endif

  LIBS_USED += htmlhelp.lib

  # add the common linker flags.  the debugging flag is added because we
  # want to be able to debug into release code, but since the pdb files
  # are separate, we're not exposing ourselves when we don't include them.
  LOAD_FLAG_PREFIX += $(PROFILER_FLAG) -debug -opt:ref -opt:icf 
#-warn:3

  # "USE_MFC" dictates whether mfc should be allowed in the application.
  # the default is not to use MFC extension style dlls.  this can be turned
  # on in the individual makefiles that require MFC.
  #USE_MFC =

  # the library creator gets a couple of flags.
  LIBRARIAN_FLAGS += -nologo -machine:X86 -subsystem:windows

  # now, vary the flag configuration based on the flags that have been set.

  ifneq "$(CONSOLE_MODE)" ""
    # console type of applications are built using the static flag so that
    # they are more redistributable.
    DEFINITIONS += _CONSOLE
    LOAD_FLAG_SUFFIX += -subsystem:console
    LIBRARIAN_FLAGS += -subsystem:console
  endif

  # dynamically linked library or application flags.
  ifneq "$(DEBUG)" ""
    # debug.
    DEFINITIONS += _DEBUG
    COMPILER_FLAGS += -MDd
  else
    # release.
    DEFINITIONS += NDEBUG
    COMPILER_FLAGS += -MD
    LOAD_FLAG_PREFIX += -map
  endif

  ifneq "$(STRICT_WARNINGS)" ""
    COMPILER_FLAGS += -WX
#would like to add W4 but that triggers warnings in ms's own headers.
  endif

endif

ifeq "$(COMPILER)" "GNU_DARWIN"
  # Darwin kernel GNU compiler...
  CC = g++
  COMPILER_ROOT_DIR = /
  PLATFORM_ADD_IN = darwin
  ARCHITECTURE = $(shell machine 2>/dev/null || arch 2>/dev/null || echo i686)
#  COMPILER_FLAGS += -fgnu-runtime

  export COMPILER_VERSION = $(shell $(SHELL) $(CLAM_DIR)/cpp/get_version.sh $(COMPILER) $(COMPILER_ROOT_DIR) )

  DEFINITIONS += _FILE_OFFSET_BITS=64 

  DEPENDENCY_DEFINITIONS += NO_VERSION
  DEPENDENCY_ADDITIONS = -X/usr/include -X/usr/include/c++/$(COMPILER_VERSION) -X/usr/include/c++/$(COMPILER_VERSION)/tr1 -X/usr/local/include -X/usr/include/linux -X/usr/include/wx-2.8 -X/usr/lib/gcc/i586-suse-linux/$(COMPILER_VERSION)/include -X/usr/lib/gcc/i486-linux-gnu/$(COMPILER_VERSION)/include

#protect other additions to make them only for debian?
#  COMPILER_HEADER_DIR := /usr/include /usr/local/include 
  COMPILER_HEADER_DIR := /System/Library/Frameworks/Foundation.framework/Versions/C/Headers

  # "USE_XWIN" specifies that this project needs X window system support.
  #USE_XWIN =

#  ifeq "x86_64" "$(ARCHITECTURE)"
#    COMPILER_LIBRARY_DIR = /lib64 /usr/lib64 /usr/local/lib64
#  else

    COMPILER_LIBRARY_DIR = /usr/lib 
###/usr/local/lib
#/lib 

#  endif
  DEFINITIONS += __LINUX__ linux __linux__ UNIX unix __UNIX__ __USE_GNU 
  # X Window System not enabled by default.
  #DEFINITIONS += __XWINDOWS__ 

  LIBRARY_TOOL = ar
  LIB_PREFIX = lib
#  LOAD_FLAG_PREFIX += -Xlinker 
#mac has no o3???
#-O3 

# -Xlinker --print-map : shows what went in and why.
# -Xlinker -O3 : linker optimization
  CREATE_LIBRARY_FLAG += -r 
    # space on end is significant.
  LINKER_OUTPUT_FLAG = -o 
  LINK_TOOL = g++
#  COMPILER_FLAGS += -shared-libgcc -fPIC  
#old: -Wl,-export-dynamic
#  ifeq "$(DEBUG)" ""
#    COMPILER_FLAGS += -finline-functions 
#  endif
#  ifneq "$(STRICT_WARNINGS)" ""
#    COMPILER_FLAGS += -Wall -Werror -Wextra -pedantic-errors -Wno-long-long
#  endif
#  LIBS_USED += dl pthread rt 
#mac no like these libs
     # dl=dynamic library.
     # pthread=thread libraries.
     # rt=real time libraries for shared memory.

  ifneq "$(DEBUG)" ""
    # add in debugging flags.
#    COMPILER_FLAGS += -g3 -O0
  endif
endif

############################################################################

# these activities are done after the compiler specific stuff.

# add a definition for programs to be able to differentiate the versions.
DEFINITIONS += COMPILER_VERSION=$(COMPILER_VERSION)

# set a variable that scripts can use to get most of the definitions.
export VARIABLE_DEFINITION_SET := $(DEFINITIONS)

###############################################################################

