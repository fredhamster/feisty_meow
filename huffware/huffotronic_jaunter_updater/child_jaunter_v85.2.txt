
// huffware script: child jaunter, by fred huffhines,  released under GPL license.
//
// this is the sub-jaunter implementation, for children of a root jaunter.  this script
// handles reconnaissance and one-way trips.
//
// this script is licensed by the GPL v3 which is documented at: http://www.gnu.org/licenses/gpl.html
// do not use it in objects without fully realizing you are implicitly accepting that license.
//

//////////////

// configurable constants...

string TEXT_COLOR = "<0.5, 0.7, 0.95>";
    // set float text color to a nice color.

integer DEBUGGING = FALSE;
    // set to true to get debugging noises.

// requires jaunting library API.
//////////////
// do not redefine these constants.
integer JAUNT_HUFFWARE_ID = 10008;
    // the unique id within the huffware system for the jaunt script to
    // accept commands on.  this is used in llMessageLinked as the num parameter.
string HUFFWARE_PARM_SEPARATOR = "{~~~}";
    // this pattern is an uncommon thing to see in text, so we use it to separate
    // our commands in link messages.
string HUFFWARE_ITEM_SEPARATOR = "{|||}";
    // used to separate lists of items from each other when stored inside a parameter.
    // this allows lists to be passed as single string parameters if needed.
integer REPLY_DISTANCE = 100008;  // offset added to service's huffware id in reply IDs.
//////////////
// commands available via the jaunting library:
string FULL_STOP_COMMAND = "#fullstop#";
    // command used to bring object to a halt.
string JAUNT_LIST_COMMAND = "#jauntlist#";
    // like regular jaunt, but expects a string in jaunt notecard format with vectors.
    // the second parameter, if any, should be 1 for forwards traversal and 0 for backwards.
//
//////////////

// the API for this library script to be used in other scripts.
//////////////
// do not redefine these constants.
integer JAUNT_REZOLATOR_HUFFWARE_ID = 10025;
    // the unique id within the huffware system for this script's commands.
    // it's used in llMessageLinked as the num parameter.
//////////////
// commands available from the library:
string RESET_REZOLATOR = "#reset";
    // tells the script to stop any previous efforts to rez children.
//string REZ_CHILD_NOW = "#rezkd#";
    // requests this script to create a new child object.  this requires several
    // parameters to succeed: 1) object to rez, 2) conveyance mode for the rezzed object
    // to implement, 3) the chat channel to listen for and speak to new child on,
    // 4) the destination name for where the child should go, 5) a count of the full
    // set of known destinations, 6) the target where the jaunt should arrive at.
string REPORT_CHILD_REZZED = "#reziam";
    // requests that this class report to the root jaunter that a child has rezzed and
    // is ready for service.  there are no required parameters.
string REZOLATOR_CHILD_SUPPORT = "#rzsup";
    // used by child jaunters to request that the rezolator handle things for them.
string REZOLATOR_CHILD_RETURNED = "#rezdon";
    // used by the child jaunter to tell the rezolator that it has jumped to wherever it
    // was supposed to and is ready to report to the parent, if needed.  the first parameter
    // required for the rezolator is whether the jump was successful (1) or not (0), and
    // the second parameter should be the last safe position that the jaunter was at when
    // it was possibly closest to the target.
//////////////
// events generated by the library:
//string REZOLATOR_EVENT_REZZED_CHILD = "#donekd";
    // an event generated for a previous rez child request.  this lets the caller know that
    // the child has been created and told what to do.  the single parameter is where the
    // jaunter has been rezzed.
string REZOLATOR_EVENT_GOT_INSTRUCTIONS = "#rzsta";
    // the root jaunter has given a child instructions on where to go.  this info includes
    // the name of the destination, the pathway to get there, and the conveyance mode.
//string REZOLATOR_EVENT_RECON_FINISHED = "#rzcnfn";
    // an event generated when the recon process has concluded.  this includes parms:
    // number of good destinations.
//
//////////////

// important constants used internally...  these should not be changed willy nilly.

////////////// jaunt base API

// the following constants define how the script should behave (i.e., its conveyance mode).
// TWO_WAY_TRIP: the script jaunts using the current target vectors to get somewhere
//   and then takes the same pathway back, but in reverse order.
// AUTOREZ_JAUNTER: the script rezzes the first regular object in its inventory next to
//   the root telehub.  that object is loaded with the destination notecard and this script.
//   the rezzed object can then be used for the next few minutes to jaunt to the selected
//   destination.  the temporary object will use the ONE_WAY_TRIP mode.
// ONE_WAY_TRIP: the object containing this script will take the user to a particular
//   destination, but the object does not survive the trip.  it self-destructs after
//   reaching the destination.  this mode is used in conjunction with the AUTOREZ_JAUNTER
//   mode and should generally never be used on its own.
// RECONNAISSANCE_TRIP: a survey run to test out a particular path to get to a
//   destination.
integer TWO_WAY_TRIP = 1;
integer AUTOREZ_JAUNTER = 2;
integer ONE_WAY_TRIP = 3;
integer RECONNAISSANCE_TRIP = 4;

// values used to represent different stages of verification.
integer VERIFY_UNTESTED = -3;  // don't know destinations tate yet.
integer VERIFY_SAFE = -4;  // the destination last tested safe.
integer VERIFY_UNSAFE_SO_FAR = -5;  // this cannot be done with simple jaunt.
integer VERIFY_UNSAFE_DECIDED = -6;  // this means the destination seems intractable.

integer MAXIMUM_PRIV_CHAN = 90000;
    // the largest amount we will ever subtract from the tricky parms in order to
    // tell the sub-jaunter which channel to listen on.

string VECTOR_SEPARATOR = "|";
    // how we separate components of vectors from each other.
string DB_SEPARATOR = "``";  // separating items in lists.

////////////// end jaunt base API

integer MAX_DEST_NAME = 24;  // the longest name that we store.

float NORMAL_TIMER_PERIOD = 1.0;  // our normal timer rate.

float POSITION_CHECKING_INTERVAL = 0.11;
    // how frequently the waiting for arrival state will check where we are.

integer MAXIMUM_SLACKNESS = 108;
    // how many timer hits we'll allow before reverting to the default state.

integer FREE_MEM_REQUIRED = 3200;
    // we need at least this much memory before adding new targets.

//////////////

// global variables.

integer startup_parm;  // recorded at rez time.  used for deciding what to do.

integer conveyance_mode;  // when we are given our instructions, we will know what type of jump to use.

// jaunter target configuration...
string global_name;  // the name for our destination.
integer global_verification_state;  // the verification state of the last destination we asked for.
string global_pathway;  // similar, but the last pathway we heard.

// jaunt trip variables...
vector eventual_destination;  // where we're headed, if we're headed anywhere.
integer slackness_counter;  // snoozes had while waiting for destination.
list full_journey;  // the full pathway we expect to jaunt on.
integer jaunt_responses_awaited;  // number of pending jumps in progress.
integer got_close_enough;  // did we arrive at right place?
vector last_safe_position;  // where did we actually reach?

// asks the jaunting library to take us to the target using a list of waypoints.
request_jaunt(list journey, integer forwards)
{
    // ask for a jump.
    jaunt_responses_awaited++;
    llMessageLinked(LINK_THIS, JAUNT_HUFFWARE_ID, JAUNT_LIST_COMMAND,
        wrap_item_list(journey) + HUFFWARE_PARM_SEPARATOR + (string)forwards);
    // stops the jaunter in its tracks.
    llMessageLinked(LINK_THIS, JAUNT_HUFFWARE_ID, FULL_STOP_COMMAND, ""); 
}

// this function returns TRUE if we are close enough to the "destination".
integer close_enough(vector destination)
{
    float PROXIMITY_REQUIRED = 0.1;
        // how close we must be to the target location to call it done.
        // matches current jaunting library proximity.
    return (llVecDist(llGetPos(), destination) <= PROXIMITY_REQUIRED);
}

// sets up the initial state.
initialize_child()
{
    llSetTimerEvent(0.0);  // cancel any existing timers.
    // load up an arrival sound if any exist.
    if (llGetInventoryNumber(INVENTORY_SOUND))
        llPreloadSound(llGetInventoryName(INVENTORY_SOUND, 0));
    if (DEBUGGING) log_it("child init startparm=" + (string)startup_parm);

//voodoo.
    llSleep(0.5);
    
    if (startup_parm != 0) {
        // tell the rezolator to start listening for commands.
        llMessageLinked(LINK_THIS, JAUNT_REZOLATOR_HUFFWARE_ID, REZOLATOR_CHILD_SUPPORT,
            wrap_parameters([startup_parm]));
        // let our parent know we're here.
        llMessageLinked(LINK_THIS, JAUNT_REZOLATOR_HUFFWARE_ID, REPORT_CHILD_REZZED, "");
    }
    // set up some of the object properties...
    llSetSitText("Jaunt");  // change to the proper text for our mode.
}

// shows our next target for jaunting above the object.
text_label_for_destination()
{
    string msg = "↣ " + global_name;
    llSetText(msg, (vector)TEXT_COLOR, 1.0);
}

// signal that we are where we were going.
proclaim_arrival()
{
    if (conveyance_mode == ONE_WAY_TRIP) {
        // sing a little song, if there's a sound to use.
        if (llGetInventoryNumber(INVENTORY_SOUND))
            llTriggerSound(llGetInventoryName(INVENTORY_SOUND, 0), 1.0);
    }
}

string verification_name(integer enumtype)
{
    if (enumtype == VERIFY_SAFE) return "ok";
    else if (enumtype == VERIFY_UNSAFE_SO_FAR) return "uhh";
    else if (enumtype == VERIFY_UNSAFE_DECIDED) return "far";
    // catch-all, including untested.
    return "?";
}

// returns true if the slackness counter awaiting things has elapsed.
integer check_for_timeout()
{
    if (slackness_counter++ > MAXIMUM_SLACKNESS) {
        // go back to the main state.  we took too long.
        log_it("timed out!");
        llUnSit(llAvatarOnSitTarget());  // don't hang onto the avatar for this error.
        llSetTimerEvent(0.0);
        return TRUE;
    }
    return FALSE;
}

//////////////

// returns the value of a boolean variable definition.
integer parse_bool_def(string def)
{ return !(llGetSubString(def, find_substring(def, "=") + 1, -1) == "0"); }

// processes link messages received from support libraries.
integer handle_link_message(integer which, integer num, string msg, string id)
{
    // is it a jaunting library response?
    if (num == JAUNT_HUFFWARE_ID + REPLY_DISTANCE) {
        jaunt_responses_awaited--;  // one less response being awaited.
        if (jaunt_responses_awaited < 0) {
            log_it("error: responses awaited < 0");
            jaunt_responses_awaited = 0;
        }
        return FALSE;
    }
    
    // is it an event from the rezolator script?
    if (num == JAUNT_REZOLATOR_HUFFWARE_ID + REPLY_DISTANCE) {
        list parms = llParseString2List(id, [HUFFWARE_PARM_SEPARATOR], []);
        if (msg == REZOLATOR_EVENT_GOT_INSTRUCTIONS) {
            global_name = llList2String(parms, 0);
            full_journey = [ llGetPos() ] + llParseString2List(llList2String(parms, 1), [VECTOR_SEPARATOR], []);
            eventual_destination = (vector)llList2String(full_journey, llGetListLength(full_journey) - 1);
            conveyance_mode = llList2Integer(parms, 2);
            if (DEBUGGING)
                log_it("got instructions: name=" + global_name + " dest=" + (string)eventual_destination);
            text_label_for_destination();
            if (conveyance_mode == RECONNAISSANCE_TRIP) {
                return TRUE;
            }
        }
        return FALSE;
    }

    return FALSE;
}

// processes a destination set to handle special cases, like for offset jaunting.
list prechewed_destinations(string dests)
{

//document this!!!
// as in, we support the offset format!

    // look for our special start character for offsets.
    if (is_prefix(dests, "o"))
        // if this is an offset version, then chop whatever word they used starting with 'o'
        // and compute the destination based on current position.
        return [ (vector)llDeleteSubString(dests, 0, find_substring(dests, "<") - 1) + llGetPos() ];
    else
        // normal jaunt to absolute coordinates.
        return llParseString2List(dests, [VECTOR_SEPARATOR], []);
}

//////////////
// from hufflets...

integer debug_num = 0;

// a debugging output method.  can be disabled entirely in one place.
log_it(string to_say)
{
    debug_num++;
    // tell this to the owner.    
    llOwnerSay(llGetScriptName() + "[" + (string)debug_num + "] " + to_say);
    // say this on open chat, but use an unusual channel.
//    llSay(108, (string)debug_num + "- " + to_say);
}

///////////////

// returns TRUE if the value in "to_check" specifies a legal x or y value in a sim.
integer valid_sim_value(float to_check)
{
    if (to_check < 0.0) return FALSE;
    if (to_check >= 257.0) return FALSE;
    return TRUE;
}

// returns TRUE if the "to_check" vector is a location outside of the current sim.
integer outside_of_sim(vector to_check)
{
    return !valid_sim_value(to_check.x) || !valid_sim_value(to_check.y);
}

// returns text for a floating point number, but includes only
// two digits after the decimal point.
string float_chop(float to_show)
{
    integer mant = llAbs(llRound(to_show * 100.0) / 100);
    string neg_sign;
    if (to_show < 0.0) neg_sign = "-";
    string dec_s = (string)((llRound(to_show * 100.0) - mant * 100) / 100.0);
    dec_s = llGetSubString(llGetSubString(dec_s, find_substring(dec_s, ".") + 1, -1), 0, 2);
    // strip off all trailing zeros.
    while (llGetSubString(dec_s, -1, -1) == "0")
        dec_s = llDeleteSubString(dec_s, -1, -1);
    string to_return = neg_sign + (string)mant;
    if (llStringLength(dec_s)) to_return += "." + dec_s;
    return to_return;
}

// returns a prettier form for vector text, with chopped floats.
string vector_chop(vector to_show)
{
    return "<" + float_chop(to_show.x) + ","
        + float_chop(to_show.y) + ","
        + float_chop(to_show.z) + ">";
}

// joins a list of parameters using the parameter sentinel for the library.
string wrap_parameters(list to_flatten)
{ return llDumpList2String(to_flatten, HUFFWARE_PARM_SEPARATOR); }
//
// joins a list of sub-items using the item sentinel for the library.
string wrap_item_list(list to_wrap)
{ return llDumpList2String(to_wrap, HUFFWARE_ITEM_SEPARATOR); }

// returns a number at most "maximum" and at least "minimum".
// if "allow_negative" is TRUE, then the return may be positive or negative.
float randomize_within_range(float minimum, float maximum, integer allow_negative)
{
    if (minimum > maximum) {
        // flip the two if they are reversed.
        float temp = minimum; minimum = maximum; maximum = temp;
    }
    float to_return = minimum + llFrand(maximum - minimum);
    if (allow_negative) {
        if (llFrand(1.0) < 0.5) to_return *= -1.0;
    }
    return to_return;
}

// returns a random vector where x,y,z will be between "minimums" and "maximums"
// x,y,z components.  if "allow_negative" is true, then any component will
// randomly be negative or positive.
vector random_bound_vector(vector minimums, vector maximums, integer allow_negative)
{
    return <randomize_within_range(minimums.x, maximums.x, allow_negative),
        randomize_within_range(minimums.y, maximums.y, allow_negative),
        randomize_within_range(minimums.z, maximums.z, allow_negative)>;
}

// returns a vector whose components are between minimum and maximum.
// if allow_negative is true, then they can be either positive or negative.
vector random_vector(float minimum, float maximum, integer allow_negative)
{
    return random_bound_vector(<minimum, minimum, minimum>,
        <maximum, maximum, maximum>, allow_negative);
}

// returns the portion of the list between start and end, but only if they are
// valid compared with the list length.  an attempt to use negative start or
// end values also returns a blank list.
list chop_list(list to_chop, integer start, integer end)
{
    integer last_len = llGetListLength(to_chop) - 1;
    if ( (start < 0) || (end < 0) || (start > last_len) || (end > last_len) ) return [];
    return llList2List(to_chop, start, end);
}

// returns the index of the first occurrence of "pattern" inside
// the "full_string".  if it is not found, then a negative number is returned.
integer find_substring(string full_string, string pattern)
{
    string full_lower = llToLower(full_string);
    return llSubStringIndex(full_lower, pattern);
}

// returns TRUE if the "prefix" string is the first part of "compare_with".
integer is_prefix(string compare_with, string prefix)
{ return find_substring(compare_with, prefix) == 0; }

//////////////
// huffware script: auto-retire, by fred huffhines, version 2.8.
// distributed under BSD-like license.
//   !!  keep in mind that this code must be *copied* into another
//   !!  script that you wish to add auto-retirement capability to.
// when a script has auto_retire in it, it can be dropped into an
// object and the most recent version of the script will destroy
// all older versions.
//
// the version numbers are embedded into the script names themselves.
// the notation for versions uses a letter 'v', followed by two numbers
// in the form "major.minor".
// major and minor versions are implicitly considered as a floating point
// number that increases with each newer version of the script.  thus,
// "hazmap v0.1" might be the first script in the "hazmap" script continuum,
// and "hazmap v3.2" is a more recent version.
//
// example usage of the auto-retirement script:
//     default {
//         state_entry() {
//            auto_retire();  // make sure newest addition is only version of script.
//        }
//     }
// this script is partly based on the self-upgrading scripts from markov brodsky
// and jippen faddoul.
//////////////
auto_retire() {
    string self = llGetScriptName();  // the name of this script.
    list split = compute_basename_and_version(self);
    if (llGetListLength(split) != 2) return;  // nothing to do for this script.
    string basename = llList2String(split, 0);  // script name with no version attached.
    string version_string = llList2String(split, 1);  // the version found.
    integer posn;
    // find any scripts that match the basename.  they are variants of this script.
    for (posn = llGetInventoryNumber(INVENTORY_SCRIPT) - 1; posn >= 0; posn--) {
        string curr_script = llGetInventoryName(INVENTORY_SCRIPT, posn);
        if ( (curr_script != self) && (llSubStringIndex(curr_script, basename) == 0) ) {
            // found a basic match at least.
            list inv_split = compute_basename_and_version(curr_script);
            if (llGetListLength(inv_split) == 2) {
                // see if this script is more ancient.
                string inv_version_string = llList2String(inv_split, 1);  // the version found.
                // must make sure that the retiring script is completely the identical basename;
                // just matching in the front doesn't make it a relative.
                if ( (llList2String(inv_split, 0) == basename)
                    && ((float)inv_version_string < (float)version_string) ) {
                    // remove script with same name from inventory that has inferior version.
                    llRemoveInventory(curr_script);
                }
            }
        }
    }
}
//
// separates the base script name and version number.  used by auto_retire.
list compute_basename_and_version(string to_chop_up)
{
    // minimum script name is 2 characters plus a version.
    integer space_v_posn;
    // find the last useful space and 'v' combo.
    for (space_v_posn = llStringLength(to_chop_up) - 3;
        (space_v_posn >= 2) && (llGetSubString(to_chop_up, space_v_posn, space_v_posn + 1) != " v");
        space_v_posn--) {
        // look for space and v but do nothing else.
    }
    if (space_v_posn < 2) return [];  // no space found.
    // now we zoom through the stuff after our beloved v character and find any evil
    // space characters, which are most likely from SL having found a duplicate item
    // name and not so helpfully renamed it for us.
    integer indy;
    for (indy = llStringLength(to_chop_up) - 1; indy > space_v_posn; indy--) {
        if (llGetSubString(to_chop_up, indy, indy) == " ") {
            // found one; zap it.  since we're going backwards we don't need to
            // adjust the loop at all.
            to_chop_up = llDeleteSubString(to_chop_up, indy, indy);
        }
    }
    string full_suffix = llGetSubString(to_chop_up, space_v_posn, -1);
    // ditch the space character for our numerical check.
    string chop_suffix = llGetSubString(full_suffix, 1, llStringLength(full_suffix) - 1);
    // strip out a 'v' if there is one.
    if (llGetSubString(chop_suffix, 0, 0) == "v")
        chop_suffix = llGetSubString(chop_suffix, 1, llStringLength(chop_suffix) - 1);
    // if valid floating point number and greater than zero, that works for our version.
    string basename = to_chop_up;  // script name with no version attached.
    if ((float)chop_suffix > 0.0) {
        // this is a big success right here.
        basename = llGetSubString(to_chop_up, 0, -llStringLength(full_suffix) - 1);
        return [ basename, chop_suffix ];
    }
    // seems like we found nothing useful.
    return [];
}
//
//////////////

//////////////

// default state scrounges for information in a notecard and looks for landmarks in
// inventory to add as destinations.
default
{
    state_entry() { if (llSubStringIndex(llGetObjectName(),  "huffotronic") < 0) state real_default; }
    on_rez(integer parm) {
        startup_parm = parm; 
        if (DEBUGGING) log_it("default onrez " + (string)startup_parm);
        state rerun;
    }
}
state rerun { state_entry() { state default; } }

state real_default
{
    state_entry() {
        auto_retire();
        if (DEBUGGING) log_it("=> real_default state, mem=" + (string)llGetFreeMemory());
        initialize_child();
        state normal_runtime;
    }
    
    on_rez(integer parm) {
        startup_parm = parm; 
        if (DEBUGGING) log_it("default onrez " + (string)startup_parm);
        state default;
    }
}

// the normal state is pretty calm; the jaunter just sits there waiting for
// an avatar who needs it to do something.
state normal_runtime
{
    state_entry() {
        if (DEBUGGING) log_it("=> normal state, mem=" + (string)llGetFreeMemory());
        jaunt_responses_awaited = 0;  // nothing pending right now.
        got_close_enough = FALSE;  // have not even tried going there yet.
    }

    on_rez(integer parm) {
        startup_parm = parm;
        if (DEBUGGING) log_it("default onrez " + (string)startup_parm);
        state default;
    }

    touch_end(integer total_number) {
        // if we got to here, we may need to check the safety of the target and show the
        // map if the conditions are right.
        if (outside_of_sim(eventual_destination)) {
            // bring up the map; maybe we can't get there from here.  definitely out of sim.
            llMapDestination(llGetRegionName(), eventual_destination, ZERO_VECTOR);
            proclaim_arrival();
        }
    }

    changed(integer change) {
        if (!(change & CHANGED_LINK)) return;  // don't care then.
//no, bad, ack.  if the jaunter has multiple parts and they sit on non-root prim, this breaks our ability to react to sit events properly.        if (llAvatarOnSitTarget() == NULL_KEY) return;  // there is no one sitting now.
        if (outside_of_sim(eventual_destination)) {
            llWhisper(0, "This type of jaunter needs to be clicked rather than sat upon.  Please left-click it (or right-click it and select 'touch').");
            llUnSit(llAvatarOnSitTarget());
            return;
        }
        state jaunting_now;  // sweet, we're off.
    }

    // process the response from the APIs we use.
    link_message(integer which, integer num, string msg, key id) {
        if (handle_link_message(which, num, msg, id)) state jaunting_now;
    }
    
}

// once someone is trying to jump to a target, this state processes the request.
state jaunting_now
{
    state_entry() {
        if (DEBUGGING) log_it("=> jauntnow state, posn=" + vector_chop(llGetPos()));
        slackness_counter = 0;
        // most jaunters go to at least the first location...
        request_jaunt(full_journey, TRUE);
        eventual_destination = (vector)llList2String(full_journey, llGetListLength(full_journey) - 1);
        llSetTimerEvent(POSITION_CHECKING_INTERVAL);
    }

    on_rez(integer parm)
    {
        startup_parm = parm;
        if (DEBUGGING) log_it("default onrez " + (string)startup_parm);
        state default;
    }

    timer() {
        if (jaunt_responses_awaited) {
            // we are not quite there yet.
            if (check_for_timeout()) state normal_runtime;  // oops.
            return;  // not time yet.
        }
        // we got to where we were going, maybe.  unseat the avatar, leaving her
        // at the destination.
        llUnSit(llAvatarOnSitTarget());
        state arrived_at_target;
    }

    // process the response from the jaunting library.
    link_message(integer which, integer num, string msg, key id)
    { handle_link_message(which, num, msg, id); }
}

// this state is activated when the first jaunt is complete.
state arrived_at_target
{
    state_entry() {
        if (DEBUGGING) log_it("=> arriv targ state, posn=" + vector_chop(llGetPos()));
        // we are close enough; get back to work.
        jaunt_responses_awaited = 0;  // nothing pending right now.
        if (conveyance_mode != RECONNAISSANCE_TRIP) {
            llWhisper(0, "↣ " + global_name);
        } else {
            if (DEBUGGING) {
                string close = "yep";
                if (!close_enough(eventual_destination)) close = "nope";
                log_it("close enough here? " + close + ", want to get to "
                    + (string)eventual_destination);
            }
            got_close_enough = close_enough(eventual_destination);
            last_safe_position = llGetPos();
        }

        // we've gotten where we were going.
        proclaim_arrival();

//hmmm: nice mod to make the one way trip actually flip its target list and allow a return.

        // reverse direction and head back without rider.
        eventual_destination = (vector)llList2String(full_journey, 0);
        request_jaunt(full_journey, FALSE);
        llSetTimerEvent(POSITION_CHECKING_INTERVAL);
        slackness_counter = 0;
        if (DEBUGGING) log_it("now trying to jaunt home, responses awaited=" + (string)jaunt_responses_awaited);
    }

    on_rez(integer parm) {
        startup_parm = parm; 
        if (DEBUGGING) log_it("default onrez " + (string)startup_parm);
        state default;
    }

    timer() {
        if (jaunt_responses_awaited) {
            // we are not quite there yet.
            if (check_for_timeout()) state normal_runtime;  // oops.
            return;  // not time yet.
        }
        if (DEBUGGING) log_it("==> telling parent we got back, now at posn: " + (string)llGetPos());
        llMessageLinked(LINK_THIS, JAUNT_REZOLATOR_HUFFWARE_ID, REZOLATOR_CHILD_RETURNED,
            wrap_parameters([got_close_enough, 
                llDumpList2String(llDeleteSubList(full_journey, 0, 0) + [ last_safe_position ],
                    VECTOR_SEPARATOR)]));
        state normal_runtime;
    }
    
    // process the response from the jaunting library.
    link_message(integer which, integer num, string msg, key id)
    { handle_link_message(which, num, msg, id); } 
}
